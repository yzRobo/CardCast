<!DOCTYPE html>
<html lang="en" data-theme="business">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CardCast - Pokemon Match Control</title>
    <link href="https://cdn.jsdelivr.net/npm/daisyui@4.4.19/dist/full.min.css" rel="stylesheet" type="text/css" />
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Minimal custom styles for specific needs */
        .pokemon-card-aspect {
            aspect-ratio: 63/88;
        }
        
        .prize-card-taken {
            opacity: 0.5;
            background: #374151 !important;
        }
        
        .search-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            z-index: 1000;
            padding: 2rem;
        }
        
        .search-overlay.active {
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        /* Stadium card cropping styles */
        .stadium-card-display {
            width: 120px;
            height: 40px;
            overflow: hidden;
            position: relative;
            border-radius: 0.375rem;
            background: #1f2937;
        }
        
        .stadium-card-display img {
            position: absolute;
            width: 100%;
            top: -15%;
            left: 0;
            transform: scale(1.2);
        }
        
        .stadium-mini-display {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            padding: 0.5rem;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-radius: 0.5rem;
            min-height: 3.5rem;
        }
        
        /* Drag and Drop Styles */
        .draggable {
            cursor: move;
            transition: transform 0.2s;
        }
        
        .draggable:hover {
            transform: scale(1.02);
        }
        
        .dragging {
            opacity: 0.5;
            transform: scale(0.95);
        }
        
        .drag-over {
            border: 2px solid #3b82f6 !important;
            background-color: rgba(59, 130, 246, 0.1) !important;
        }
        
        .drop-zone {
            min-height: 112px;
            transition: all 0.3s;
        }
        
        .active-drop-zone {
            min-height: 112px;
            position: relative;
        }
        
        .bench-drop-zone {
            position: relative;
        }
        
        /* Visual feedback during drag */
        .drag-placeholder {
            border: 3px dashed #3b82f6;
            background: rgba(59, 130, 246, 0.05);
            display: flex;
            align-items: center;
            justify-content: center;
            color: #3b82f6;
            font-weight: bold;
        }
        
        /* Stadium search results */
        .stadium-search-results {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: #1f2937;
            border: 1px solid #374151;
            border-radius: 0.5rem;
            margin-top: 0.25rem;
            max-height: 300px;
            overflow-y: auto;
            z-index: 50;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1);
        }
        
        .stadium-search-item {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            padding: 0.5rem;
            cursor: pointer;
            transition: background 0.2s;
        }
        
        .stadium-search-item:hover {
            background: #374151;
        }
        
        .stadium-search-item img {
            width: 60px;
            height: 84px;
            object-fit: cover;
            border-radius: 0.25rem;
        }
        
        /* Deck selector styles */
        .deck-selector {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.5rem;
            background: rgba(59, 130, 246, 0.1);
            border-radius: 0.5rem;
            margin-bottom: 0.5rem;
        }
        
        .deck-selector select {
            flex: 1;
        }
        
        .deck-info {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 0.875rem;
            color: #9ca3af;
        }
    </style>
</head>
<body class="min-h-screen bg-base-300">
    <!-- Header -->
    <div class="navbar bg-base-100 shadow-lg fixed top-0 z-40">
        <div class="flex-1">
            <h1 class="text-xl font-bold">CardCast - Pokemon Match Control</h1>
            <a href="/" class="btn btn-ghost btn-sm ml-4">‚Üê Back to Main</a>
        </div>
        <div class="flex-none">
            <div class="badge badge-lg" id="overlayStatus">
                <span class="badge badge-error">Overlay Not Connected</span>
            </div>
        </div>
    </div>

    <!-- Main Container -->
    <div class="container mx-auto px-4 pt-20 pb-8">
        <!-- Stadium Control -->
        <div class="card bg-base-100 shadow-xl mb-6">
            <div class="card-body py-4">
                <div class="flex items-center justify-between">
                    <div class="flex items-center gap-4 flex-1">
                        <label class="text-sm font-semibold whitespace-nowrap">Stadium in Play:</label>
                        
                        <!-- Stadium Display Area -->
                        <div id="stadiumDisplay" class="flex-1">
                            <!-- Empty state -->
                            <div id="emptyStadium" class="flex items-center gap-4">
                                <div class="relative flex-1 max-w-md">
                                    <input type="text" 
                                           id="stadiumSearch" 
                                           placeholder="Search for a Stadium card..." 
                                           class="input input-bordered input-sm w-full"
                                           autocomplete="off">
                                    <div id="stadiumSearchResults" class="stadium-search-results hidden"></div>
                                </div>
                                <span class="text-sm text-base-content/50">or</span>
                                <input type="text" 
                                       id="stadiumManual" 
                                       placeholder="Type stadium name manually" 
                                       class="input input-bordered input-sm flex-1 max-w-xs">
                                <button class="btn btn-primary btn-sm" onclick="setManualStadium()">Set</button>
                            </div>
                            
                            <!-- Active stadium display (hidden by default) -->
                            <div id="activeStadium" class="stadium-mini-display hidden">
                                <div class="stadium-card-display">
                                    <img id="stadiumCardImage" src="" alt="Stadium">
                                </div>
                                <div class="flex-1">
                                    <div id="stadiumCardName" class="font-bold text-white"></div>
                                    <div id="stadiumCardSet" class="text-xs text-white/70"></div>
                                </div>
                                <button class="btn btn-error btn-sm" onclick="clearStadium()">Remove</button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="grid lg:grid-cols-2 gap-6">
            <!-- Player 1 Controls -->
            <div class="card bg-base-100 shadow-xl border-t-4 border-primary">
                <div class="card-body">
                    <div class="flex items-center justify-between mb-2">
                        <input type="text" id="player1Name" value="Player 1" 
                               class="input input-ghost text-xl font-bold w-40">
                        <div class="flex items-center gap-2">
                            <span class="text-sm">Record:</span>
                            <input type="number" id="player1Wins" value="0" min="0" class="input input-bordered input-xs w-12">
                            <span>/</span>
                            <input type="number" id="player1Losses" value="0" min="0" class="input input-bordered input-xs w-12">
                            <span>/</span>
                            <input type="number" id="player1Ties" value="0" min="0" class="input input-bordered input-xs w-12">
                            <button class="btn btn-xs" onclick="updatePlayerRecord(1)">Set</button>
                        </div>
                    </div>
                    
                    <!-- Deck Selector -->
                    <div class="deck-selector">
                        <label class="text-sm font-semibold">Deck:</label>
                        <select id="player1Deck" class="select select-bordered select-sm" onchange="updatePlayerDeck(1)">
                            <option value="">No Deck (Search All Cards)</option>
                        </select>
                        <div class="deck-info" id="player1DeckInfo"></div>
                    </div>
                    
                    <div class="flex items-center gap-4 mb-2">
                        <span class="text-sm">Games Won in Match:</span>
                        <div class="join">
                            <button class="btn btn-xs join-item" onclick="updateMatchScore(1, -1)">-</button>
                            <span class="join-item bg-base-200 px-3 py-1 text-sm" id="player1MatchScore">0</span>
                            <button class="btn btn-xs join-item" onclick="updateMatchScore(1, 1)">+</button>
                        </div>
                    </div>
                    
                    <!-- Active Pokemon -->
                    <div class="divider">Active Pokemon</div>
                    <div class="flex items-center gap-4 p-4 bg-base-200 rounded-lg active-drop-zone" 
                         id="player1Active"
                         data-player="1"
                         data-slot="active">
                        <div class="w-20 h-28 bg-base-300 border-2 border-dashed border-base-content/20 rounded flex items-center justify-center">
                            <span class="text-base-content/50">Empty</span>
                        </div>
                        <div class="flex-1">
                            <button class="btn btn-primary btn-sm" onclick="selectPokemonFor('player1', 'active')">
                                Select Pokemon
                            </button>
                        </div>
                    </div>
                    
                    <!-- HP Control -->
                    <div class="flex items-center gap-2 mt-2">
                        <span class="text-sm">HP:</span>
                        <input type="number" id="player1ActiveHp" class="input input-bordered input-sm w-20" value="0" min="0">
                        <span>/</span>
                        <input type="number" id="player1ActiveMaxHp" class="input input-bordered input-sm w-20" value="0" min="0">
                        <button class="btn btn-sm" onclick="updateActiveHp(1)">Update</button>
                    </div>
                    
                    <!-- Bench -->
                    <div class="divider">Bench</div>
                    <div class="flex items-center gap-2 mb-2">
                        <span class="text-sm">Bench Size:</span>
                        <select id="player1BenchSize" class="select select-bordered select-sm" onchange="updateBenchSize(1)">
                            <option value="5">5 (Standard)</option>
                            <option value="7">7 (Stadium/Ability)</option>
                        </select>
                    </div>
                    <div class="grid grid-cols-4 gap-2" id="player1Bench">
                        <!-- Bench slots will be generated by JavaScript -->
                    </div>
                    
                    <!-- Prize Cards -->
                    <div class="divider">Prize Cards</div>
                    <div class="grid grid-cols-6 gap-2" id="player1Prizes">
                        <div class="pokemon-card-aspect bg-gradient-to-br from-primary to-secondary rounded cursor-pointer hover:scale-110 transition-transform flex items-center justify-center text-white font-bold"
                             onclick="togglePrize(1, 0)">1</div>
                        <div class="pokemon-card-aspect bg-gradient-to-br from-primary to-secondary rounded cursor-pointer hover:scale-110 transition-transform flex items-center justify-center text-white font-bold"
                             onclick="togglePrize(1, 1)">2</div>
                        <div class="pokemon-card-aspect bg-gradient-to-br from-primary to-secondary rounded cursor-pointer hover:scale-110 transition-transform flex items-center justify-center text-white font-bold"
                             onclick="togglePrize(1, 2)">3</div>
                        <div class="pokemon-card-aspect bg-gradient-to-br from-primary to-secondary rounded cursor-pointer hover:scale-110 transition-transform flex items-center justify-center text-white font-bold"
                             onclick="togglePrize(1, 3)">4</div>
                        <div class="pokemon-card-aspect bg-gradient-to-br from-primary to-secondary rounded cursor-pointer hover:scale-110 transition-transform flex items-center justify-center text-white font-bold"
                             onclick="togglePrize(1, 4)">5</div>
                        <div class="pokemon-card-aspect bg-gradient-to-br from-primary to-secondary rounded cursor-pointer hover:scale-110 transition-transform flex items-center justify-center text-white font-bold"
                             onclick="togglePrize(1, 5)">6</div>
                    </div>
                    
                    <!-- Turn Actions -->
                    <div class="divider">Turn Actions</div>
                    <div class="grid grid-cols-3 gap-2">
                        <div>
                            <label class="text-xs">Energy</label>
                            <div class="flex items-center gap-1">
                                <input type="checkbox" id="player1Energy" class="checkbox checkbox-sm" onchange="updateTurnActions(1)">
                                <span class="text-xs">Attached</span>
                            </div>
                        </div>
                        <div>
                            <label class="text-xs">Supporter</label>
                            <div class="flex items-center gap-1">
                                <input type="checkbox" id="player1Supporter" class="checkbox checkbox-sm" onchange="updateTurnActions(1)">
                                <span class="text-xs">Played</span>
                            </div>
                        </div>
                        <div>
                            <label class="text-xs">Retreat</label>
                            <div class="flex items-center gap-1">
                                <input type="checkbox" id="player1Retreat" class="checkbox checkbox-sm" onchange="updateTurnActions(1)">
                                <span class="text-xs">Used</span>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Player 2 Controls -->
            <div class="card bg-base-100 shadow-xl border-t-4 border-error">
                <div class="card-body">
                    <div class="flex items-center justify-between mb-2">
                        <input type="text" id="player2Name" value="Player 2" 
                               class="input input-ghost text-xl font-bold w-40">
                        <div class="flex items-center gap-2">
                            <span class="text-sm">Record:</span>
                            <input type="number" id="player2Wins" value="0" min="0" class="input input-bordered input-xs w-12">
                            <span>/</span>
                            <input type="number" id="player2Losses" value="0" min="0" class="input input-bordered input-xs w-12">
                            <span>/</span>
                            <input type="number" id="player2Ties" value="0" min="0" class="input input-bordered input-xs w-12">
                            <button class="btn btn-xs" onclick="updatePlayerRecord(2)">Set</button>
                        </div>
                    </div>
                    
                    <!-- Deck Selector -->
                    <div class="deck-selector">
                        <label class="text-sm font-semibold">Deck:</label>
                        <select id="player2Deck" class="select select-bordered select-sm" onchange="updatePlayerDeck(2)">
                            <option value="">No Deck (Search All Cards)</option>
                        </select>
                        <div class="deck-info" id="player2DeckInfo"></div>
                    </div>
                    
                    <div class="flex items-center gap-4 mb-2">
                        <span class="text-sm">Games Won in Match:</span>
                        <div class="join">
                            <button class="btn btn-xs join-item" onclick="updateMatchScore(2, -1)">-</button>
                            <span class="join-item bg-base-200 px-3 py-1 text-sm" id="player2MatchScore">0</span>
                            <button class="btn btn-xs join-item" onclick="updateMatchScore(2, 1)">+</button>
                        </div>
                    </div>
                    
                    <!-- Active Pokemon -->
                    <div class="divider">Active Pokemon</div>
                    <div class="flex items-center gap-4 p-4 bg-base-200 rounded-lg active-drop-zone" 
                         id="player2Active"
                         data-player="2"
                         data-slot="active">
                        <div class="w-20 h-28 bg-base-300 border-2 border-dashed border-base-content/20 rounded flex items-center justify-center">
                            <span class="text-base-content/50">Empty</span>
                        </div>
                        <div class="flex-1">
                            <button class="btn btn-primary btn-sm" onclick="selectPokemonFor('player2', 'active')">
                                Select Pokemon
                            </button>
                        </div>
                    </div>
                    
                    <!-- HP Control -->
                    <div class="flex items-center gap-2 mt-2">
                        <span class="text-sm">HP:</span>
                        <input type="number" id="player2ActiveHp" class="input input-bordered input-sm w-20" value="0" min="0">
                        <span>/</span>
                        <input type="number" id="player2ActiveMaxHp" class="input input-bordered input-sm w-20" value="0" min="0">
                        <button class="btn btn-sm" onclick="updateActiveHp(2)">Update</button>
                    </div>
                    
                    <!-- Bench -->
                    <div class="divider">Bench</div>
                    <div class="flex items-center gap-2 mb-2">
                        <span class="text-sm">Bench Size:</span>
                        <select id="player2BenchSize" class="select select-bordered select-sm" onchange="updateBenchSize(2)">
                            <option value="5">5 (Standard)</option>
                            <option value="7">7 (Stadium/Ability)</option>
                        </select>
                    </div>
                    <div class="grid grid-cols-4 gap-2" id="player2Bench">
                        <!-- Bench slots will be generated by JavaScript -->
                    </div>
                    
                    <!-- Prize Cards -->
                    <div class="divider">Prize Cards</div>
                    <div class="grid grid-cols-6 gap-2" id="player2Prizes">
                        <div class="pokemon-card-aspect bg-gradient-to-br from-primary to-secondary rounded cursor-pointer hover:scale-110 transition-transform flex items-center justify-center text-white font-bold"
                             onclick="togglePrize(2, 0)">1</div>
                        <div class="pokemon-card-aspect bg-gradient-to-br from-primary to-secondary rounded cursor-pointer hover:scale-110 transition-transform flex items-center justify-center text-white font-bold"
                             onclick="togglePrize(2, 1)">2</div>
                        <div class="pokemon-card-aspect bg-gradient-to-br from-primary to-secondary rounded cursor-pointer hover:scale-110 transition-transform flex items-center justify-center text-white font-bold"
                             onclick="togglePrize(2, 2)">3</div>
                        <div class="pokemon-card-aspect bg-gradient-to-br from-primary to-secondary rounded cursor-pointer hover:scale-110 transition-transform flex items-center justify-center text-white font-bold"
                             onclick="togglePrize(2, 3)">4</div>
                        <div class="pokemon-card-aspect bg-gradient-to-br from-primary to-secondary rounded cursor-pointer hover:scale-110 transition-transform flex items-center justify-center text-white font-bold"
                             onclick="togglePrize(2, 4)">5</div>
                        <div class="pokemon-card-aspect bg-gradient-to-br from-primary to-secondary rounded cursor-pointer hover:scale-110 transition-transform flex items-center justify-center text-white font-bold"
                             onclick="togglePrize(2, 5)">6</div>
                    </div>
                    
                    <!-- Turn Actions -->
                    <div class="divider">Turn Actions</div>
                    <div class="grid grid-cols-3 gap-2">
                        <div>
                            <label class="text-xs">Energy</label>
                            <div class="flex items-center gap-1">
                                <input type="checkbox" id="player2Energy" class="checkbox checkbox-sm" onchange="updateTurnActions(2)">
                                <span class="text-xs">Attached</span>
                            </div>
                        </div>
                        <div>
                            <label class="text-xs">Supporter</label>
                            <div class="flex items-center gap-1">
                                <input type="checkbox" id="player2Supporter" class="checkbox checkbox-sm" onchange="updateTurnActions(2)">
                                <span class="text-xs">Played</span>
                            </div>
                        </div>
                        <div>
                            <label class="text-xs">Retreat</label>
                            <div class="flex items-center gap-1">
                                <input type="checkbox" id="player2Retreat" class="checkbox checkbox-sm" onchange="updateTurnActions(2)">
                                <span class="text-xs">Used</span>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Match Controls -->
        <div class="card bg-base-100 shadow-xl mt-6">
            <div class="card-body">
                <!-- Match Setup -->
                <div class="border-b border-base-300 pb-4">
                    <h3 class="text-sm uppercase tracking-wider text-primary font-semibold mb-3">Match Setup</h3>
                    <div class="flex flex-wrap items-center gap-4">
                        <div class="form-control">
                            <label class="label">
                                <span class="label-text text-xs">Format</span>
                            </label>
                            <select id="matchFormat" class="select select-bordered select-sm">
                                <option value="Best of 1">Best of 1</option>
                                <option value="Best of 3" selected>Best of 3</option>
                            </select>
                        </div>
                        <div class="form-control">
                            <label class="label">
                                <span class="label-text text-xs">Game</span>
                            </label>
                            <select id="gameNumber" class="select select-bordered select-sm">
                                <option value="1">Game 1</option>
                                <option value="2">Game 2</option>
                                <option value="3">Game 3</option>
                            </select>
                        </div>
                        <button class="btn btn-primary btn-sm mt-6" onclick="updateMatchSettings()">Apply Settings</button>
                    </div>
                </div>
                
                <!-- Timer Control -->
                <div class="border-b border-base-300 py-4">
                    <h3 class="text-sm uppercase tracking-wider text-primary font-semibold mb-3">Timer Control</h3>
                    <div class="flex flex-wrap items-center gap-4">
                        <div class="text-5xl font-mono font-bold text-primary bg-base-200 px-6 py-3 rounded-lg" id="timerDisplay">50:00</div>
                        <div class="flex gap-2">
                            <button class="btn btn-success" onclick="startTimer()">‚ñ∂ Start</button>
                            <button class="btn btn-warning" onclick="pauseTimer()">‚è∏ Pause</button>
                            <button class="btn btn-neutral" onclick="resetTimer()">‚Ü∫ Reset</button>
                        </div>
                    </div>
                </div>
                
                <!-- Turn Control -->
                <div class="border-b border-base-300 py-4">
                    <h3 class="text-sm uppercase tracking-wider text-primary font-semibold mb-3">Turn Control</h3>
                    <div class="flex flex-wrap items-center gap-4">
                        <div class="badge badge-lg badge-primary p-4" id="turnDisplay">Player 1's Turn</div>
                        <button class="btn btn-primary" onclick="switchTurn()">Switch Turn</button>
                        <button class="btn btn-warning btn-sm" onclick="resetTurnActions()">Reset Turn Actions</button>
                    </div>
                </div>
                
                <!-- Overlay Display -->
                <div class="border-b border-base-300 py-4">
                    <h3 class="text-sm uppercase tracking-wider text-primary font-semibold mb-3">Overlay Display</h3>
                    <div class="flex gap-2">
                        <button class="btn btn-success" onclick="showPokemonOverlay()">Show Overlay</button>
                        <button class="btn btn-warning" onclick="hidePokemonOverlay()">Hide Overlay</button>
                    </div>
                </div>
                
                <!-- Match Reset -->
                <div class="pt-4">
                    <h3 class="text-sm uppercase tracking-wider text-primary font-semibold mb-3">Match Reset</h3>
                    <div class="flex items-center gap-4">
                        <button class="btn btn-error" onclick="resetMatch()">üîÑ Reset Entire Match</button>
                        <span class="text-xs text-error opacity-70 italic">This will clear all Pokemon, prizes, and timer</span>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Updated Search Overlay -->
    <div class="search-overlay" id="searchOverlay">
        <div class="card w-full max-w-5xl bg-base-100">
            <div class="card-body">
                <div class="flex justify-between items-center mb-4">
                    <h2 class="card-title">Select Pokemon</h2>
                    <button class="btn btn-circle btn-ghost" onclick="closeSearch()">‚úï</button>
                </div>
                
                <!-- Search mode indicator -->
                <div id="searchModeIndicator" class="alert alert-info mb-4 hidden">
                    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" class="stroke-current shrink-0 w-6 h-6"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>
                    <span id="searchModeText"></span>
                </div>
                
                <div class="flex gap-2 mb-4">
                    <input type="text" id="pokemonSearch" placeholder="Filter cards..." 
                           class="input input-bordered flex-1">
                           
                    <!-- Toggle for searching all cards vs deck -->
                    <div class="form-control">
                        <label class="label cursor-pointer flex gap-2">
                            <span class="label-text whitespace-nowrap">Search all cards</span>
                            <input type="checkbox" id="searchAllCards" class="toggle toggle-primary" onchange="toggleSearchMode()">
                        </label>
                    </div>
                </div>
                
                <!-- Increased grid size and max height for better viewing -->
                <div class="grid grid-cols-3 sm:grid-cols-4 md:grid-cols-5 lg:grid-cols-6 xl:grid-cols-8 gap-3 max-h-[600px] overflow-y-auto p-2" 
                     id="searchResults">
                    <!-- Search results will appear here -->
                </div>
            </div>
        </div>
    </div>
    
    <!-- Socket.io -->
    <script src="/socket.io/socket.io.js"></script>
    <script>
        const socket = io();
        
        let matchState = {
            player1: {
                name: 'Player 1',
                active: null,
                benchSize: 5,
                bench: [null, null, null, null, null, null, null],
                prizes: [false, false, false, false, false, false],
                record: { wins: 0, losses: 0, ties: 0 },
                matchScore: 0,
                turnActions: { energy: false, supporter: false, retreat: false },
                deckId: null,
                deckName: null
            },
            player2: {
                name: 'Player 2',
                active: null,
                benchSize: 5,
                bench: [null, null, null, null, null, null, null],
                prizes: [false, false, false, false, false, false],
                record: { wins: 0, losses: 0, ties: 0 },
                matchScore: 0,
                turnActions: { energy: false, supporter: false, retreat: false },
                deckId: null,
                deckName: null
            },
            currentTurn: 1,
            timer: { minutes: 50, seconds: 0 },
            timerInterval: null,
            gameNumber: 1,
            matchFormat: 'Best of 3',
            stadium: null
        };
        
        let currentSelection = null;
        let draggedPokemon = null;
        let draggedFrom = null;
        let stadiumSearchTimeout = null;
        let availableDecks = [];
        let playerDeckCards = {
            player1: [],
            player2: []
        };
        
        // Initialize
        document.addEventListener('DOMContentLoaded', () => {
            // Load available decks
            loadAvailableDecks();
            
            // Load saved state if any
            loadMatchState();
            
            // Initialize bench displays
            updateBenchDisplay(1);
            updateBenchDisplay(2);
            
            // Setup drag and drop for active zones
            setupActiveZoneDragDrop(1);
            setupActiveZoneDragDrop(2);
            
            // Setup search with updated function
            document.getElementById('pokemonSearch').addEventListener('input', debounce(searchPokemon, 300));
            
            // Setup stadium search
            document.getElementById('stadiumSearch').addEventListener('input', debounce(searchStadiums, 300));
            document.getElementById('stadiumSearch').addEventListener('focus', () => {
                const results = document.getElementById('stadiumSearchResults');
                if (results.children.length > 0) {
                    results.classList.remove('hidden');
                }
            });
            
            // Close stadium search when clicking outside
            document.addEventListener('click', (e) => {
                if (!e.target.closest('#stadiumSearch') && !e.target.closest('#stadiumSearchResults')) {
                    document.getElementById('stadiumSearchResults').classList.add('hidden');
                }
            });
            
            // Update player names on change
            document.getElementById('player1Name').addEventListener('change', updatePlayerNames);
            document.getElementById('player2Name').addEventListener('change', updatePlayerNames);
            
            // Register with server
            socket.emit('register-control', 'pokemon-match');
            
            // Listen for overlay connections
            socket.on('overlay-connected', (type) => {
                if (type === 'pokemon-match') {
                    updateOverlayStatus(true);
                }
            });
            
            socket.on('overlay-disconnected', (type) => {
                if (type === 'pokemon-match') {
                    updateOverlayStatus(false);
                }
            });

            socket.on('connect', () => {
                console.log('Control panel connected to server');
                socket.emit('register-control', 'pokemon-match');
                
                // Request overlay status
                socket.emit('check-overlay-status', 'pokemon-match');
            });
        });
        
        // NEW FUNCTION: Populate deck cards when opening search
        async function populateDeckCards() {
            const searchAllCards = document.getElementById('searchAllCards').checked;
            
            if (!currentSelection) return;
            
            const playerNum = currentSelection.player === 'player1' ? 1 : 2;
            const deckCardNames = playerDeckCards[`player${playerNum}`];
            
            // If no deck selected or searching all cards, don't pre-populate
            if (deckCardNames.length === 0 || searchAllCards) {
                document.getElementById('searchResults').innerHTML = '<div class="col-span-full text-center text-base-content/50">Search for Pokemon cards to add...</div>';
                return;
            }
            
            // Get unique card names from deck
            const uniqueCardNames = [...new Set(deckCardNames)];
            
            // Fetch card data for all unique cards in the deck
            const allCards = [];
            const loadingIndicator = document.getElementById('searchResults');
            loadingIndicator.innerHTML = '<div class="col-span-full text-center"><span class="loading loading-spinner loading-md"></span> Loading Pokemon from deck...</div>';
            
            for (const cardName of uniqueCardNames) {
                try {
                    const response = await fetch(`/api/search/pokemon?q=${encodeURIComponent(cardName)}`);
                    const results = await response.json();
                    
                    // Find the best match for this card name - ONLY POKEMON
                    const exactMatch = results.find(card => 
                        card.name.toLowerCase() === cardName.toLowerCase() && isPokemonCard(card)
                    );
                    
                    if (exactMatch) {
                        allCards.push(exactMatch);
                    } else {
                        // If no exact match, look for first Pokemon result
                        const firstPokemon = results.find(card => isPokemonCard(card));
                        if (firstPokemon) {
                            allCards.push(firstPokemon);
                        }
                    }
                } catch (error) {
                    console.error(`Error fetching card: ${cardName}`, error);
                }
            }
            
            // Display all Pokemon cards from deck
            displaySearchResults(allCards);
        }
        
        // Helper function to determine if a card is a Pokemon
        function isPokemonCard(card) {
            // Check if card has HP (Pokemon cards have HP)
            if (card.hp && parseInt(card.hp) > 0) {
                return true;
            }
            
            // Additional checks based on card properties
            // Trainers and Energy typically don't have HP
            const cardNameLower = card.name.toLowerCase();
            
            // Common trainer keywords to exclude
            const trainerKeywords = ['trainer', 'supporter', 'item', 'tool', 'stadium'];
            for (const keyword of trainerKeywords) {
                if (card.type?.toLowerCase().includes(keyword) || 
                    card.category?.toLowerCase().includes(keyword)) {
                    return false;
                }
            }
            
            // Common energy keywords to exclude
            const energyKeywords = ['energy', 'basic energy'];
            for (const keyword of energyKeywords) {
                if (cardNameLower.includes(keyword) || 
                    card.type?.toLowerCase().includes(keyword) ||
                    card.category?.toLowerCase().includes(keyword)) {
                    return false;
                }
            }
            
            // If we're not sure but it doesn't have HP, it's probably not a Pokemon
            return false;
        }
        
        // Deck Management Functions
        async function loadAvailableDecks() {
            try {
                // Load decks from localStorage (same as main index.html)
                const savedDecks = JSON.parse(localStorage.getItem('savedDecks')) || {};
                availableDecks = [];
                
                // Convert saved decks to flat array for easier use
                Object.keys(savedDecks).forEach(game => {
                    if (game === 'pokemon') {  // Only show Pokemon decks
                        savedDecks[game].forEach(deck => {
                            availableDecks.push({
                                id: `${game}-${deck.name}`,
                                name: deck.name,
                                game: game,
                                ...deck
                            });
                        });
                    }
                });
                
                // Update both player deck selectors
                updateDeckSelectors();
            } catch (error) {
                console.error('Error loading decks:', error);
            }
        }
        
        function updateDeckSelectors() {
            const player1Select = document.getElementById('player1Deck');
            const player2Select = document.getElementById('player2Deck');
            
            // Create options HTML
            let optionsHTML = '<option value="">No Deck (Search All Cards)</option>';
            availableDecks.forEach(deck => {
                optionsHTML += `<option value="${deck.id}">${deck.name}</option>`;
            });
            
            // Preserve current selections
            const player1Current = player1Select.value;
            const player2Current = player2Select.value;
            
            player1Select.innerHTML = optionsHTML;
            player2Select.innerHTML = optionsHTML;
            
            // Restore selections if they still exist
            if (player1Current && availableDecks.find(d => d.id == player1Current)) {
                player1Select.value = player1Current;
            }
            if (player2Current && availableDecks.find(d => d.id == player2Current)) {
                player2Select.value = player2Current;
            }
        }
        
        async function updatePlayerDeck(playerNum) {
            const deckSelect = document.getElementById(`player${playerNum}Deck`);
            const deckId = deckSelect.value;
            const deckInfo = document.getElementById(`player${playerNum}DeckInfo`);
            
            if (!deckId) {
                // No deck selected - search all cards
                matchState[`player${playerNum}`].deckId = null;
                matchState[`player${playerNum}`].deckName = null;
                playerDeckCards[`player${playerNum}`] = [];
                deckInfo.innerHTML = '<span class="text-xs">Searching all cards</span>';
            } else {
                // Load the selected deck from localStorage
                try {
                    const savedDecks = JSON.parse(localStorage.getItem('savedDecks')) || {};
                    const [game, ...nameParts] = deckId.split('-');
                    const deckName = nameParts.join('-');
                    
                    const deck = savedDecks[game]?.find(d => d.name === deckName);
                    
                    if (!deck) {
                        throw new Error('Deck not found');
                    }
                    
                    matchState[`player${playerNum}`].deckId = deckId;
                    matchState[`player${playerNum}`].deckName = deck.name;
                    
                    // Extract all card names from the deck
                    const cardNames = [];
                    if (deck.pokemon) {
                        deck.pokemon.forEach(p => {
                            for (let i = 0; i < (p.quantity || p.count || 1); i++) {
                                cardNames.push(p.name);
                            }
                        });
                    }
                    if (deck.trainers) {
                        deck.trainers.forEach(t => {
                            for (let i = 0; i < (t.quantity || t.count || 1); i++) {
                                cardNames.push(t.name);
                            }
                        });
                    }
                    if (deck.energy) {
                        deck.energy.forEach(e => {
                            for (let i = 0; i < (e.quantity || e.count || 1); i++) {
                                cardNames.push(e.name);
                            }
                        });
                    }
                    
                    playerDeckCards[`player${playerNum}`] = cardNames;
                    
                    // Count unique cards
                    const uniqueCount = new Set(cardNames).size;
                    deckInfo.innerHTML = `<span class="text-xs">${cardNames.length} cards (${uniqueCount} unique)</span>`;
                    
                } catch (error) {
                    console.error('Error loading deck:', error);
                    deckInfo.innerHTML = '<span class="text-xs text-error">Error loading deck</span>';
                }
            }
            
            saveMatchState();
        }
        
        // UPDATED: Toggle search mode with deck card display
        function toggleSearchMode() {
            const searchAllCards = document.getElementById('searchAllCards').checked;
            updateSearchModeIndicator();
            
            const searchInput = document.getElementById('pokemonSearch');
            
            // If search input is empty, populate deck cards or clear
            if (searchInput.value.length === 0) {
                if (searchAllCards) {
                    document.getElementById('searchResults').innerHTML = '<div class="col-span-full text-center text-base-content/50">Search for Pokemon cards to add...</div>';
                } else {
                    populateDeckCards();
                }
            } else if (searchInput.value.length >= 2) {
                // Re-trigger search if there's text in the search box
                searchPokemon({ target: searchInput });
            }
        }
        
        function updateSearchModeIndicator() {
            const indicator = document.getElementById('searchModeIndicator');
            const indicatorText = document.getElementById('searchModeText');
            const searchAllCards = document.getElementById('searchAllCards').checked;
            
            if (!currentSelection) return;
            
            const playerNum = currentSelection.player === 'player1' ? 1 : 2;
            const deckName = matchState[`player${playerNum}`].deckName;
            
            if (deckName && !searchAllCards) {
                indicator.classList.remove('hidden');
                indicatorText.textContent = `Searching in deck: ${deckName}`;
            } else if (searchAllCards && deckName) {
                indicator.classList.remove('hidden');
                indicatorText.textContent = `Searching all cards (deck restriction disabled)`;
            } else {
                indicator.classList.add('hidden');
            }
        }
        
        // Stadium Functions
        async function searchStadiums(event) {
            const query = event.target.value;
            const resultsContainer = document.getElementById('stadiumSearchResults');
            
            if (query.length < 2) {
                resultsContainer.classList.add('hidden');
                resultsContainer.innerHTML = '';
                return;
            }
            
            try {
                // Use the same search as Pokemon - just search all cards
                const response = await fetch(`/api/search/pokemon?q=${encodeURIComponent(query)}`);
                const results = await response.json();
                
                // Since we can't filter by type, show all results
                // User can visually identify stadium cards
                if (results.length > 0) {
                    displayStadiumResults(results);
                    resultsContainer.classList.remove('hidden');
                } else {
                    resultsContainer.innerHTML = '<div class="p-2 text-sm text-base-content/50">No cards found</div>';
                    resultsContainer.classList.remove('hidden');
                }
            } catch (error) {
                console.error('Stadium search error:', error);
            }
        }
        
        function displayStadiumResults(cards) {
            const container = document.getElementById('stadiumSearchResults');
            container.innerHTML = cards.map(card => `
                <div class="stadium-search-item" onclick="selectStadiumCard('${card.id}')">
                    <img src="${card.display_image || card.local_image || card.image_url}" alt="${card.name}">
                    <div class="flex-1">
                        <div class="font-semibold">${card.name}</div>
                        <div class="text-xs opacity-70">${card.set_name || ''}</div>
                    </div>
                </div>
            `).join('');
        }
        
        async function selectStadiumCard(cardId) {
            try {
                // Try pokemon endpoint first, then trainer if that fails
                let response = await fetch(`/api/card/pokemon/${cardId}`);
                if (!response.ok) {
                    response = await fetch(`/api/card/trainer/${cardId}`);
                }
                const card = await response.json();
                
                const stadium = {
                    id: card.id,
                    name: card.name,
                    image: card.display_image || card.local_image || card.image_url,
                    set: card.set_name || ''
                };
                
                setActiveStadium(stadium);
                
                // Clear and hide search
                document.getElementById('stadiumSearch').value = '';
                document.getElementById('stadiumSearchResults').classList.add('hidden');
                document.getElementById('stadiumSearchResults').innerHTML = '';
            } catch (error) {
                console.error('Error selecting stadium:', error);
            }
        }
        
        function setActiveStadium(stadium) {
            matchState.stadium = stadium;
            
            // Update UI
            document.getElementById('emptyStadium').classList.add('hidden');
            document.getElementById('activeStadium').classList.remove('hidden');
            document.getElementById('stadiumCardImage').src = stadium.image;
            document.getElementById('stadiumCardName').textContent = stadium.name;
            document.getElementById('stadiumCardSet').textContent = stadium.set;
            
            // Send to overlay
            socket.emit('stadium-update', { stadium: stadium });
            saveMatchState();
        }
        
        function setManualStadium() {
            const manualName = document.getElementById('stadiumManual').value;
            if (!manualName.trim()) return;
            
            const stadium = {
                id: 'manual',
                name: manualName,
                image: null,
                set: 'Custom'
            };
            
            matchState.stadium = stadium;
            
            // For manual stadiums, just show the name without image
            document.getElementById('emptyStadium').classList.add('hidden');
            document.getElementById('activeStadium').classList.remove('hidden');
            document.getElementById('stadiumCardImage').style.display = 'none';
            document.getElementById('stadiumCardImage').parentElement.style.display = 'none';
            document.getElementById('stadiumCardName').textContent = stadium.name;
            document.getElementById('stadiumCardSet').textContent = 'Custom Entry';
            
            // Clear manual input
            document.getElementById('stadiumManual').value = '';
            
            socket.emit('stadium-update', { stadium: stadium });
            saveMatchState();
        }
        
        function clearStadium() {
            matchState.stadium = null;
            
            // Reset UI
            document.getElementById('emptyStadium').classList.remove('hidden');
            document.getElementById('activeStadium').classList.add('hidden');
            document.getElementById('stadiumSearch').value = '';
            document.getElementById('stadiumManual').value = '';
            
            // Reset image display
            const imageContainer = document.getElementById('stadiumCardImage').parentElement;
            imageContainer.style.display = '';
            document.getElementById('stadiumCardImage').style.display = '';
            
            socket.emit('stadium-update', { stadium: null });
            saveMatchState();
        }
        
        // Player Record Functions
        function updatePlayerRecord(playerNum) {
            const wins = parseInt(document.getElementById(`player${playerNum}Wins`).value) || 0;
            const losses = parseInt(document.getElementById(`player${playerNum}Losses`).value) || 0;
            const ties = parseInt(document.getElementById(`player${playerNum}Ties`).value) || 0;
            
            matchState[`player${playerNum}`].record = { wins, losses, ties };
            
            socket.emit('record-update', { 
                player: playerNum, 
                record: { wins, losses, ties }
            });
            
            saveMatchState();
        }
        
        function updateMatchScore(playerNum, delta) {
            const currentScore = matchState[`player${playerNum}`].matchScore || 0;
            const newScore = Math.max(0, currentScore + delta);
            
            matchState[`player${playerNum}`].matchScore = newScore;
            document.getElementById(`player${playerNum}MatchScore`).textContent = newScore;
            
            socket.emit('match-score-update', { 
                player: playerNum, 
                score: newScore 
            });
            
            saveMatchState();
        }
        
        // Turn Actions Functions
        function updateTurnActions(playerNum) {
            const energy = document.getElementById(`player${playerNum}Energy`).checked;
            const supporter = document.getElementById(`player${playerNum}Supporter`).checked;
            const retreat = document.getElementById(`player${playerNum}Retreat`).checked;
            
            matchState[`player${playerNum}`].turnActions = { energy, supporter, retreat };
            
            socket.emit('turn-actions-update', { 
                player: playerNum, 
                actions: { energy, supporter, retreat }
            });
            
            saveMatchState();
        }
        
        function resetTurnActions() {
            // Reset both players' turn actions
            [1, 2].forEach(playerNum => {
                document.getElementById(`player${playerNum}Energy`).checked = false;
                document.getElementById(`player${playerNum}Supporter`).checked = false;
                document.getElementById(`player${playerNum}Retreat`).checked = false;
                
                matchState[`player${playerNum}`].turnActions = { 
                    energy: false, 
                    supporter: false, 
                    retreat: false 
                };
            });
            
            socket.emit('turn-actions-reset');
            saveMatchState();
        }
        
        // Bench Size Functions
        function updateBenchSize(playerNum) {
            const newSize = parseInt(document.getElementById(`player${playerNum}BenchSize`).value);
            matchState[`player${playerNum}`].benchSize = newSize;
            
            updateBenchDisplay(playerNum);
            
            socket.emit('bench-size-update', { 
                player: playerNum, 
                size: newSize 
            });
            
            saveMatchState();
        }
        
        // Drag and Drop Functions
        function setupActiveZoneDragDrop(playerNum) {
            const activeZone = document.getElementById(`player${playerNum}Active`);
            
            activeZone.addEventListener('dragover', handleDragOver);
            activeZone.addEventListener('drop', handleDrop);
            activeZone.addEventListener('dragleave', handleDragLeave);
        }
        
        function setupBenchSlotDragDrop(element, playerNum, benchIndex) {
            element.addEventListener('dragover', handleDragOver);
            element.addEventListener('drop', handleDrop);
            element.addEventListener('dragleave', handleDragLeave);
            element.dataset.player = playerNum;
            element.dataset.slot = 'bench';
            element.dataset.benchIndex = benchIndex;
        }
        
        function handleDragStart(e, playerNum, slot, benchIndex = null) {
            const player = matchState[`player${playerNum}`];
            
            if (slot === 'active' && player.active) {
                draggedPokemon = player.active;
                draggedFrom = { player: playerNum, slot: 'active' };
            } else if (slot === 'bench' && player.bench[benchIndex]) {
                draggedPokemon = player.bench[benchIndex];
                draggedFrom = { player: playerNum, slot: 'bench', index: benchIndex };
            }
            
            if (draggedPokemon) {
                e.dataTransfer.effectAllowed = 'move';
                e.target.classList.add('dragging');
            }
        }
        
        function handleDragEnd(e) {
            e.target.classList.remove('dragging');
            
            // Remove all drag-over classes
            document.querySelectorAll('.drag-over').forEach(el => {
                el.classList.remove('drag-over');
            });
        }
        
        function handleDragOver(e) {
            e.preventDefault();
            e.dataTransfer.dropEffect = 'move';
            
            const dropZone = e.currentTarget;
            if (!dropZone.classList.contains('drag-over')) {
                dropZone.classList.add('drag-over');
            }
        }
        
        function handleDragLeave(e) {
            if (e.currentTarget === e.target || !e.currentTarget.contains(e.relatedTarget)) {
                e.currentTarget.classList.remove('drag-over');
            }
        }
        
        function handleDrop(e) {
            e.preventDefault();
            e.currentTarget.classList.remove('drag-over');
            
            if (!draggedPokemon || !draggedFrom) return;
            
            const dropZone = e.currentTarget;
            const targetPlayer = parseInt(dropZone.dataset.player);
            const targetSlot = dropZone.dataset.slot;
            const targetBenchIndex = dropZone.dataset.benchIndex ? parseInt(dropZone.dataset.benchIndex) : null;
            
            // Perform the swap
            performPokemonSwap(draggedFrom, {
                player: targetPlayer,
                slot: targetSlot,
                index: targetBenchIndex
            });
            
            // Reset drag state
            draggedPokemon = null;
            draggedFrom = null;
        }
        
        function performPokemonSwap(from, to) {
            const fromPlayer = matchState[`player${from.player}`];
            const toPlayer = matchState[`player${to.player}`];
            
            let fromPokemon = null;
            let toPokemon = null;
            
            // Get the Pokemon being moved
            if (from.slot === 'active') {
                fromPokemon = fromPlayer.active;
            } else if (from.slot === 'bench') {
                fromPokemon = fromPlayer.bench[from.index];
            }
            
            // Get the Pokemon at destination (if any)
            if (to.slot === 'active') {
                toPokemon = toPlayer.active;
            } else if (to.slot === 'bench') {
                toPokemon = toPlayer.bench[to.index];
            }
            
            // Perform the swap
            if (from.slot === 'active') {
                fromPlayer.active = toPokemon;
            } else if (from.slot === 'bench') {
                fromPlayer.bench[from.index] = toPokemon;
            }
            
            if (to.slot === 'active') {
                toPlayer.active = fromPokemon;
            } else if (to.slot === 'bench') {
                toPlayer.bench[to.index] = fromPokemon;
            }
            
            // Update displays
            updateActiveDisplay(from.player);
            updateBenchDisplay(from.player);
            
            if (from.player !== to.player) {
                updateActiveDisplay(to.player);
                updateBenchDisplay(to.player);
            }
            
            // Emit updates to server
            if (from.slot === 'active' || to.slot === 'active') {
                socket.emit('active-pokemon', { 
                    player: from.player, 
                    pokemon: fromPlayer.active 
                });
                
                if (from.player !== to.player) {
                    socket.emit('active-pokemon', { 
                        player: to.player, 
                        pokemon: toPlayer.active 
                    });
                }
            }
            
            socket.emit('bench-update', { 
                player: from.player, 
                bench: fromPlayer.bench.slice(0, fromPlayer.benchSize).filter(p => p !== null)
            });
            
            if (from.player !== to.player) {
                socket.emit('bench-update', { 
                    player: to.player, 
                    bench: toPlayer.bench.slice(0, toPlayer.benchSize).filter(p => p !== null)
                });
            }
            
            saveMatchState();
        }
        
        function updateOverlayStatus(connected) {
            const status = document.getElementById('overlayStatus');
            if (connected) {
                status.innerHTML = '<span class="badge badge-success">Overlay Connected</span>';
            } else {
                status.innerHTML = '<span class="badge badge-error">Overlay Not Connected</span>';
            }
        }
        
        // UPDATED: Select Pokemon with deck card population
        function selectPokemonFor(player, slot, benchIndex = null) {
            currentSelection = { player, slot, benchIndex };
            document.getElementById('searchOverlay').classList.add('active');
            document.getElementById('pokemonSearch').value = ''; // Clear search input
            document.getElementById('pokemonSearch').focus();
            
            // Reset search mode checkbox
            document.getElementById('searchAllCards').checked = false;
            
            // Update search mode indicator
            updateSearchModeIndicator();
            
            // Populate deck cards immediately
            populateDeckCards();
        }
        
        // UPDATED: Search Pokemon with better deck filtering
        async function searchPokemon(event) {
            const query = event.target.value.trim();
            
            // If query is empty and we have a deck, show all deck cards
            if (query.length === 0) {
                populateDeckCards();
                return;
            }
            
            if (query.length < 2) {
                document.getElementById('searchResults').innerHTML = '';
                return;
            }
            
            const searchAllCards = document.getElementById('searchAllCards').checked;
            const playerNum = currentSelection.player === 'player1' ? 1 : 2;
            const deckCardNames = playerDeckCards[`player${playerNum}`];
            
            try {
                // Always search all cards from the API
                const response = await fetch(`/api/search/pokemon?q=${encodeURIComponent(query)}`);
                let results = await response.json();
                
                // Filter to only Pokemon cards
                results = results.filter(card => isPokemonCard(card));
                
                // If deck is selected and not searching all cards, filter by deck card names
                if (deckCardNames.length > 0 && !searchAllCards) {
                    // Create a map of normalized deck card names for better matching
                    const deckCardNamesNormalized = new Set(
                        deckCardNames.map(name => 
                            name.toLowerCase()
                                .replace(/[^a-z0-9\s]/g, '') // Remove special characters
                                .replace(/\s+/g, ' ')         // Normalize spaces
                                .trim()
                        )
                    );
                    
                    // Also keep original names for exact matching
                    const deckCardNamesLower = new Set(deckCardNames.map(name => name.toLowerCase()));
                    
                    results = results.filter(card => {
                        const cardNameLower = card.name.toLowerCase();
                        const cardNameNormalized = cardNameLower
                            .replace(/[^a-z0-9\s]/g, '')
                            .replace(/\s+/g, ' ')
                            .trim();
                        
                        // Check both exact and normalized matches
                        return deckCardNamesLower.has(cardNameLower) || 
                               deckCardNamesNormalized.has(cardNameNormalized);
                    });
                    
                    // Remove duplicates by card name
                    const uniqueResults = [];
                    const seenNames = new Set();
                    for (const card of results) {
                        if (!seenNames.has(card.name.toLowerCase())) {
                            seenNames.add(card.name.toLowerCase());
                            uniqueResults.push(card);
                        }
                    }
                    results = uniqueResults;
                }
                
                displaySearchResults(results);
            } catch (error) {
                console.error('Search error:', error);
            }
        }
        
        // UPDATED: Display search results with better messages
        function displaySearchResults(results) {
            const container = document.getElementById('searchResults');
            
            if (results.length === 0) {
                const searchAllCards = document.getElementById('searchAllCards').checked;
                const playerNum = currentSelection.player === 'player1' ? 1 : 2;
                const hasDeck = playerDeckCards[`player${playerNum}`].length > 0;
                
                let message = 'No Pokemon cards found';
                if (hasDeck && !searchAllCards) {
                    message = 'No Pokemon cards found in deck. Try enabling "Search all cards" to search outside the deck.';
                }
                
                container.innerHTML = `<div class="col-span-full text-center text-base-content/50">${message}</div>`;
                return;
            }
            
            // Remove duplicates by card ID
            const uniqueCards = [];
            const seenIds = new Set();
            for (const card of results) {
                if (!seenIds.has(card.id)) {
                    seenIds.add(card.id);
                    uniqueCards.push(card);
                }
            }
            
            container.innerHTML = uniqueCards.map(card => `
                <div class="card bg-base-200 cursor-pointer hover:shadow-lg transition-shadow" 
                     onclick="selectPokemon('${card.id}')">
                    <figure class="px-2 pt-2">
                        <img src="${card.display_image || card.local_image || card.image_url}" 
                             class="rounded-lg pokemon-card-aspect object-cover w-full"
                             onerror="this.src='/images/card-back.png'">
                    </figure>
                    <div class="card-body p-2">
                        <p class="text-xs font-semibold">${card.name}</p>
                        <p class="text-xs opacity-70">HP: ${card.hp || '?'}</p>
                    </div>
                </div>
            `).join('');
        }
        
        async function selectPokemon(cardId) {
            try {
                // Try all endpoints to find the card
                let response = await fetch(`/api/card/pokemon/${cardId}`);
                if (!response.ok) {
                    response = await fetch(`/api/card/trainer/${cardId}`);
                }
                if (!response.ok) {
                    response = await fetch(`/api/card/energy/${cardId}`);
                }
                
                const card = await response.json();
                
                const pokemon = {
                    id: card.id,
                    name: card.name,
                    image: card.display_image || card.local_image || card.image_url,
                    maxHp: parseInt(card.hp) || 100,
                    currentHp: parseInt(card.hp) || 100
                };
                
                const playerNum = currentSelection.player === 'player1' ? 1 : 2;
                
                if (currentSelection.slot === 'active') {
                    matchState[currentSelection.player].active = pokemon;
                    updateActiveDisplay(playerNum);
                    socket.emit('active-pokemon', { player: playerNum, pokemon });
                } else if (currentSelection.slot === 'bench') {
                    matchState[currentSelection.player].bench[currentSelection.benchIndex] = pokemon;
                    updateBenchDisplay(playerNum);
                    socket.emit('bench-update', { 
                        player: playerNum, 
                        bench: matchState[currentSelection.player].bench.slice(0, matchState[currentSelection.player].benchSize).filter(p => p !== null)
                    });
                }
                
                closeSearch();
                saveMatchState();
            } catch (error) {
                console.error('Error selecting Pokemon:', error);
            }
        }
        
        function updateActiveDisplay(playerNum) {
            const player = matchState[`player${playerNum}`];
            const container = document.getElementById(`player${playerNum}Active`);
            
            if (player.active) {
                container.innerHTML = `
                    <div class="draggable" draggable="true" 
                         onDragStart="handleDragStart(event, ${playerNum}, 'active')"
                         onDragEnd="handleDragEnd(event)">
                        <img src="${player.active.image}" class="w-20 h-28 object-cover rounded cursor-move">
                    </div>
                    <div class="flex-1">
                        <div class="font-bold">${player.active.name}</div>
                        <div class="text-sm opacity-70">HP: ${player.active.currentHp}/${player.active.maxHp}</div>
                        <div class="text-xs text-info mt-1">üîÑ Drag to swap positions</div>
                        <button class="btn btn-error btn-xs mt-2" onclick="removeActive(${playerNum})">Remove</button>
                    </div>
                `;
                
                document.getElementById(`player${playerNum}ActiveHp`).value = player.active.currentHp;
                document.getElementById(`player${playerNum}ActiveMaxHp`).value = player.active.maxHp;
            } else {
                container.innerHTML = `
                    <div class="w-20 h-28 bg-base-300 border-2 border-dashed border-base-content/20 rounded flex items-center justify-center">
                        <span class="text-base-content/50">Empty</span>
                    </div>
                    <div class="flex-1">
                        <button class="btn btn-primary btn-sm" onclick="selectPokemonFor('player${playerNum}', 'active')">
                            Select Pokemon
                        </button>
                        <div class="text-xs text-info mt-2">üí° Drop Pokemon here from bench</div>
                    </div>
                `;
            }
        }
        
        function updateBenchDisplay(playerNum) {
            const player = matchState[`player${playerNum}`];
            const container = document.getElementById(`player${playerNum}Bench`);
            const benchSize = player.benchSize;
            
            let benchHTML = '';
            for (let i = 0; i < benchSize; i++) {
                const pokemon = player.bench[i];
                if (pokemon) {
                    benchHTML += `
                        <div class="bench-drop-zone relative group" 
                             data-player="${playerNum}" 
                             data-slot="bench" 
                             data-benchIndex="${i}">
                            <div class="draggable" draggable="true"
                                 onDragStart="handleDragStart(event, ${playerNum}, 'bench', ${i})"
                                 onDragEnd="handleDragEnd(event)">
                                <img src="${pokemon.image}" class="pokemon-card-aspect object-cover rounded w-full cursor-move">
                            </div>
                            <button class="btn btn-circle btn-xs btn-error absolute top-1 right-1 opacity-0 group-hover:opacity-100 transition-opacity"
                                    onclick="removeBench(${playerNum}, ${i})">√ó</button>
                        </div>
                    `;
                } else {
                    benchHTML += `
                        <div class="bench-drop-zone pokemon-card-aspect bg-base-300 border-2 border-dashed border-base-content/20 rounded cursor-pointer hover:border-primary transition-colors flex items-center justify-center" 
                             onclick="selectPokemonFor('player${playerNum}', 'bench', ${i})"
                             data-player="${playerNum}" 
                             data-slot="bench" 
                             data-benchIndex="${i}">
                            <span class="text-2xl">+</span>
                        </div>
                    `;
                }
            }
            
            container.innerHTML = benchHTML;
            
            // Adjust grid columns based on bench size
            if (benchSize === 7) {
                container.className = 'grid grid-cols-4 gap-2';
            } else {
                container.className = 'grid grid-cols-5 gap-2';
            }
            
            // Setup drag and drop for all bench slots
            container.querySelectorAll('.bench-drop-zone').forEach((element, index) => {
                if (index < benchSize) {
                    setupBenchSlotDragDrop(element, playerNum, index);
                }
            });
        }
        
        function removeActive(playerNum) {
            matchState[`player${playerNum}`].active = null;
            updateActiveDisplay(playerNum);
            socket.emit('active-pokemon', { player: playerNum, pokemon: null });
            saveMatchState();
        }
        
        function removeBench(playerNum, index) {
            matchState[`player${playerNum}`].bench[index] = null;
            updateBenchDisplay(playerNum);
            socket.emit('bench-update', { 
                player: playerNum, 
                bench: matchState[`player${playerNum}`].bench.slice(0, matchState[`player${playerNum}`].benchSize).filter(p => p !== null)
            });
            saveMatchState();
        }
        
        function updateActiveHp(playerNum) {
            const currentHp = parseInt(document.getElementById(`player${playerNum}ActiveHp`).value);
            const maxHp = parseInt(document.getElementById(`player${playerNum}ActiveMaxHp`).value);
            
            if (matchState[`player${playerNum}`].active) {
                matchState[`player${playerNum}`].active.currentHp = currentHp;
                matchState[`player${playerNum}`].active.maxHp = maxHp;
                
                socket.emit('active-pokemon', { 
                    player: playerNum, 
                    pokemon: matchState[`player${playerNum}`].active 
                });
                
                updateActiveDisplay(playerNum);
                saveMatchState();
            }
        }
        
        function togglePrize(playerNum, prizeIndex) {
            const prizes = matchState[`player${playerNum}`].prizes;
            prizes[prizeIndex] = !prizes[prizeIndex];
            
            const prizeCard = document.querySelector(`#player${playerNum}Prizes > div:nth-child(${prizeIndex + 1})`);
            if (prizes[prizeIndex]) {
                prizeCard.classList.add('prize-card-taken');
                socket.emit('prize-taken', { player: playerNum, index: prizeIndex });
            } else {
                prizeCard.classList.remove('prize-card-taken');
            }
            
            // Update prize count
            const takenCount = prizes.filter(p => p).length;
            socket.emit('pokemon-match-update', {
                [`player${playerNum}`]: {
                    prizes: 6 - takenCount,
                    prizesTaken: prizes.map((taken, i) => taken ? i : null).filter(i => i !== null)
                }
            });
            
            saveMatchState();
        }
        
        function updatePlayerNames() {
            matchState.player1.name = document.getElementById('player1Name').value;
            matchState.player2.name = document.getElementById('player2Name').value;
            
            socket.emit('pokemon-match-update', {
                player1: { name: matchState.player1.name },
                player2: { name: matchState.player2.name }
            });
            
            updateTurnDisplay();
            saveMatchState();
        }
        
        function switchTurn() {
            matchState.currentTurn = matchState.currentTurn === 1 ? 2 : 1;
            
            // Optionally reset turn actions when switching turns
            resetTurnActions();
            
            socket.emit('turn-switch', { currentTurn: matchState.currentTurn });
            updateTurnDisplay();
            saveMatchState();
        }
        
        function updateTurnDisplay() {
            const playerName = matchState[`player${matchState.currentTurn}`].name;
            document.getElementById('turnDisplay').textContent = `${playerName}'s Turn`;
        }
        
        // Timer functions
        function startTimer() {
            if (matchState.timerInterval) return;
            
            socket.emit('timer-start');
            
            matchState.timerInterval = setInterval(() => {
                if (matchState.timer.seconds > 0) {
                    matchState.timer.seconds--;
                } else if (matchState.timer.minutes > 0) {
                    matchState.timer.minutes--;
                    matchState.timer.seconds = 59;
                } else {
                    pauseTimer();
                }
                updateTimerDisplay();
            }, 1000);
        }
        
        function pauseTimer() {
            if (matchState.timerInterval) {
                clearInterval(matchState.timerInterval);
                matchState.timerInterval = null;
                socket.emit('timer-pause');
            }
        }
        
        function resetTimer() {
            pauseTimer();
            matchState.timer = { minutes: 50, seconds: 0 };
            updateTimerDisplay();
            socket.emit('timer-reset');
            saveMatchState();
        }
        
        function updateTimerDisplay() {
            const minutes = String(matchState.timer.minutes).padStart(2, '0');
            const seconds = String(matchState.timer.seconds).padStart(2, '0');
            document.getElementById('timerDisplay').textContent = `${minutes}:${seconds}`;
        }
        
        function updateMatchSettings() {
            matchState.gameNumber = parseInt(document.getElementById('gameNumber').value);
            matchState.matchFormat = document.getElementById('matchFormat').value;
            
            socket.emit('match-settings', {
                gameNumber: matchState.gameNumber,
                matchFormat: matchState.matchFormat
            });
            
            saveMatchState();
        }
        
        function showPokemonOverlay() {
            socket.emit('toggle-pokemon-match', { show: true });
            console.log('Showing Pokemon overlay');
        }
        
        function hidePokemonOverlay() {
            socket.emit('toggle-pokemon-match', { show: false });
            console.log('Hiding Pokemon overlay');
        }
        
        function resetMatch() {
            if (!confirm('Reset the entire match? This will clear all Pokemon, prizes, and timer.')) {
                return;
            }
            
            // Preserve deck selections
            const player1DeckId = matchState.player1.deckId;
            const player1DeckName = matchState.player1.deckName;
            const player2DeckId = matchState.player2.deckId;
            const player2DeckName = matchState.player2.deckName;
            
            matchState = {
                player1: {
                    name: document.getElementById('player1Name').value,
                    active: null,
                    benchSize: 5,
                    bench: [null, null, null, null, null, null, null],
                    prizes: [false, false, false, false, false, false],
                    record: { wins: 0, losses: 0, ties: 0 },
                    matchScore: 0,
                    turnActions: { energy: false, supporter: false, retreat: false },
                    deckId: player1DeckId,
                    deckName: player1DeckName
                },
                player2: {
                    name: document.getElementById('player2Name').value,
                    active: null,
                    benchSize: 5,
                    bench: [null, null, null, null, null, null, null],
                    prizes: [false, false, false, false, false, false],
                    record: { wins: 0, losses: 0, ties: 0 },
                    matchScore: 0,
                    turnActions: { energy: false, supporter: false, retreat: false },
                    deckId: player2DeckId,
                    deckName: player2DeckName
                },
                currentTurn: 1,
                timer: { minutes: 50, seconds: 0 },
                timerInterval: null,
                gameNumber: matchState.gameNumber,
                matchFormat: matchState.matchFormat,
                stadium: null
            };
            
            // Reset UI
            updateActiveDisplay(1);
            updateActiveDisplay(2);
            updateBenchDisplay(1);
            updateBenchDisplay(2);
            
            // Reset prizes UI
            document.querySelectorAll('#player1Prizes > div, #player2Prizes > div').forEach(card => {
                card.classList.remove('prize-card-taken');
            });
            
            // Reset bench sizes
            document.getElementById('player1BenchSize').value = 5;
            document.getElementById('player2BenchSize').value = 5;
            
            // Reset records
            document.getElementById('player1Wins').value = 0;
            document.getElementById('player1Losses').value = 0;
            document.getElementById('player1Ties').value = 0;
            document.getElementById('player2Wins').value = 0;
            document.getElementById('player2Losses').value = 0;
            document.getElementById('player2Ties').value = 0;
            
            // Reset match scores
            document.getElementById('player1MatchScore').textContent = '0';
            document.getElementById('player2MatchScore').textContent = '0';
            
            // Reset turn actions
            resetTurnActions();
            
            // Clear stadium
            clearStadium();
            
            updateTimerDisplay();
            updateTurnDisplay();
            
            socket.emit('match-reset');
            saveMatchState();
        }
        
        // UPDATED: Close search with input clearing
        function closeSearch() {
            document.getElementById('searchOverlay').classList.remove('active');
            document.getElementById('pokemonSearch').value = '';
            document.getElementById('searchResults').innerHTML = '';
            document.getElementById('searchModeIndicator').classList.add('hidden');
            currentSelection = null;
        }
        
        function saveMatchState() {
            localStorage.setItem('pokemonMatchState', JSON.stringify(matchState));
        }
        
        function loadMatchState() {
            const saved = localStorage.getItem('pokemonMatchState');
            if (saved) {
                matchState = JSON.parse(saved);
                
                // Update UI
                document.getElementById('player1Name').value = matchState.player1.name;
                document.getElementById('player2Name').value = matchState.player2.name;
                document.getElementById('gameNumber').value = matchState.gameNumber;
                document.getElementById('matchFormat').value = matchState.matchFormat;
                
                // Load deck selections
                if (matchState.player1.deckId) {
                    document.getElementById('player1Deck').value = matchState.player1.deckId;
                    updatePlayerDeck(1);
                }
                if (matchState.player2.deckId) {
                    document.getElementById('player2Deck').value = matchState.player2.deckId;
                    updatePlayerDeck(2);
                }
                
                // Load stadium
                if (matchState.stadium) {
                    if (matchState.stadium.image) {
                        setActiveStadium(matchState.stadium);
                    } else {
                        // Handle legacy string format or manual stadiums
                        const stadium = typeof matchState.stadium === 'string' 
                            ? { id: 'manual', name: matchState.stadium, image: null, set: 'Custom' }
                            : matchState.stadium;
                        setActiveStadium(stadium);
                    }
                }
                
                // Load bench sizes
                document.getElementById('player1BenchSize').value = matchState.player1.benchSize || 5;
                document.getElementById('player2BenchSize').value = matchState.player2.benchSize || 5;
                
                // Load records
                if (matchState.player1.record) {
                    document.getElementById('player1Wins').value = matchState.player1.record.wins || 0;
                    document.getElementById('player1Losses').value = matchState.player1.record.losses || 0;
                    document.getElementById('player1Ties').value = matchState.player1.record.ties || 0;
                }
                if (matchState.player2.record) {
                    document.getElementById('player2Wins').value = matchState.player2.record.wins || 0;
                    document.getElementById('player2Losses').value = matchState.player2.record.losses || 0;
                    document.getElementById('player2Ties').value = matchState.player2.record.ties || 0;
                }
                
                // Load match scores
                document.getElementById('player1MatchScore').textContent = matchState.player1.matchScore || 0;
                document.getElementById('player2MatchScore').textContent = matchState.player2.matchScore || 0;
                
                // Load turn actions
                if (matchState.player1.turnActions) {
                    document.getElementById('player1Energy').checked = matchState.player1.turnActions.energy || false;
                    document.getElementById('player1Supporter').checked = matchState.player1.turnActions.supporter || false;
                    document.getElementById('player1Retreat').checked = matchState.player1.turnActions.retreat || false;
                }
                if (matchState.player2.turnActions) {
                    document.getElementById('player2Energy').checked = matchState.player2.turnActions.energy || false;
                    document.getElementById('player2Supporter').checked = matchState.player2.turnActions.supporter || false;
                    document.getElementById('player2Retreat').checked = matchState.player2.turnActions.retreat || false;
                }
                
                updateActiveDisplay(1);
                updateActiveDisplay(2);
                updateBenchDisplay(1);
                updateBenchDisplay(2);
                
                // Update prizes
                matchState.player1.prizes.forEach((taken, i) => {
                    if (taken) {
                        document.querySelector(`#player1Prizes > div:nth-child(${i + 1})`).classList.add('prize-card-taken');
                    }
                });
                matchState.player2.prizes.forEach((taken, i) => {
                    if (taken) {
                        document.querySelector(`#player2Prizes > div:nth-child(${i + 1})`).classList.add('prize-card-taken');
                    }
                });
                
                updateTimerDisplay();
                updateTurnDisplay();
                
                // Send state to overlays
                socket.emit('pokemon-match-update', {
                    player1: matchState.player1,
                    player2: matchState.player2,
                    stadium: matchState.stadium
                });
            }
        }
        
        function debounce(func, wait) {
            let timeout;
            return function executedFunction(...args) {
                const later = () => {
                    clearTimeout(timeout);
                    func(...args);
                };
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
            };
        }
        
        // Make functions available globally
        window.selectPokemonFor = selectPokemonFor;
        window.selectPokemon = selectPokemon;
        window.selectStadiumCard = selectStadiumCard;
        window.setManualStadium = setManualStadium;
        window.removeActive = removeActive;
        window.removeBench = removeBench;
        window.updateActiveHp = updateActiveHp;
        window.togglePrize = togglePrize;
        window.updatePlayerNames = updatePlayerNames;
        window.switchTurn = switchTurn;
        window.startTimer = startTimer;
        window.pauseTimer = pauseTimer;
        window.resetTimer = resetTimer;
        window.updateMatchSettings = updateMatchSettings;
        window.showPokemonOverlay = showPokemonOverlay;
        window.hidePokemonOverlay = hidePokemonOverlay;
        window.resetMatch = resetMatch;
        window.closeSearch = closeSearch;
        window.handleDragStart = handleDragStart;
        window.handleDragEnd = handleDragEnd;
        window.clearStadium = clearStadium;
        window.updatePlayerRecord = updatePlayerRecord;
        window.updateMatchScore = updateMatchScore;
        window.updateTurnActions = updateTurnActions;
        window.resetTurnActions = resetTurnActions;
        window.updateBenchSize = updateBenchSize;
        window.updatePlayerDeck = updatePlayerDeck;
        window.toggleSearchMode = toggleSearchMode;
    </script>
</body>
</html>