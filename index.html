<!DOCTYPE html>
<html lang="en" data-theme="night">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CardCast - TCG Streaming Overlay Tool</title>
    <link rel="stylesheet" href="/css/style.css">
    <style>
        /* Deck View Styles */
        .deck-view-mode {
            background: linear-gradient(135deg, rgba(139, 92, 246, 0.1) 0%, rgba(59, 130, 246, 0.1) 100%);
        }
        
        .deck-section {
            margin-bottom: 2rem;
        }
        
        .deck-section-header {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 1rem;
            padding-bottom: 0.5rem;
            border-bottom: 2px solid rgba(255, 255, 255, 0.1);
        }
        
        .deck-section-title {
            font-size: 1.125rem;
            font-weight: 600;
            color: rgba(255, 255, 255, 0.9);
        }
        
        .deck-section-count {
            background: rgba(139, 92, 246, 0.2);
            color: #a78bfa;
            padding: 0.125rem 0.5rem;
            border-radius: 9999px;
            font-size: 0.875rem;
            font-weight: 500;
        }
        
        .deck-card-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
            gap: 1rem;
            min-height: 150px;
            padding: 0.5rem;
            border-radius: 0.5rem;
            transition: background 0.2s;
        }
        
        .deck-card-grid.drag-over {
            background: rgba(59, 130, 246, 0.1);
            border: 2px dashed rgba(59, 130, 246, 0.5);
        }
        
        .deck-card-item {
            position: relative;
            cursor: pointer;
            transition: transform 0.2s;
        }
        
        .deck-card-item:hover {
            transform: scale(1.05);
            z-index: 10;
        }
        
        .deck-card-item.dragging {
            opacity: 0.5;
            cursor: grabbing;
        }
        
        .deck-card-item.drag-placeholder {
            border: 2px dashed rgba(139, 92, 246, 0.5);
            background: rgba(139, 92, 246, 0.1);
            border-radius: 0.5rem;
        }
        
        .deck-card-item.edit-mode {
            cursor: grab;
        }
        
        .deck-card-item.edit-mode:active {
            cursor: grabbing;
        }
        
        .deck-card-item.edit-mode:hover .deck-card-controls {
            opacity: 1;
        }
        
        .deck-card-quantity {
            position: absolute;
            bottom: -0.25rem;
            right: -0.25rem;
            background: linear-gradient(135deg, #dc2626 0%, #ef4444 100%);
            color: white;
            width: 2rem;
            height: 2rem;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 1.125rem;
            border: 2px solid #1f2937;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
        }
        
        .deck-card-controls {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            background: rgba(0, 0, 0, 0.8);
            border-radius: 0.5rem 0.5rem 0 0;
            padding: 0.25rem;
            display: flex;
            justify-content: space-between;
            opacity: 0;
            transition: opacity 0.2s;
            z-index: 20;
        }
        
        .deck-card-control-btn {
            background: rgba(255, 255, 255, 0.2);
            color: white;
            border: none;
            border-radius: 0.25rem;
            width: 1.5rem;
            height: 1.5rem;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-weight: bold;
            transition: background 0.2s;
        }
        
        .deck-card-control-btn:hover {
            background: rgba(255, 255, 255, 0.3);
        }
        
        .deck-card-control-btn.remove {
            background: rgba(239, 68, 68, 0.5);
        }
        
        .deck-card-control-btn.remove:hover {
            background: rgba(239, 68, 68, 0.7);
        }
        
        .deck-card-image {
            width: 100%;
            height: auto;
            border-radius: 0.5rem;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
        
        .deck-view-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 1rem;
            background: rgba(31, 41, 55, 0.5);
            border-radius: 0.5rem;
            margin-bottom: 1.5rem;
        }
        
        .deck-info {
            display: flex;
            flex-direction: column;
            gap: 0.25rem;
        }
        
        .deck-name {
            font-size: 1.5rem;
            font-weight: bold;
            color: #fff;
        }
        
        .deck-name-input {
            font-size: 1.5rem;
            font-weight: bold;
            background: transparent;
            border: 2px solid transparent;
            color: #fff;
            padding: 0.25rem;
            border-radius: 0.25rem;
            transition: border-color 0.2s;
        }
        
        .deck-name-input:focus {
            outline: none;
            border-color: rgba(139, 92, 246, 0.5);
            background: rgba(0, 0, 0, 0.2);
        }
        
        .deck-stats {
            display: flex;
            gap: 1rem;
            font-size: 0.875rem;
            color: rgba(255, 255, 255, 0.7);
        }
        
        .deck-stat {
            display: flex;
            align-items: center;
            gap: 0.25rem;
        }
        
        .deck-actions {
            display: flex;
            gap: 0.5rem;
        }
        
        .empty-section {
            padding: 2rem;
            text-align: center;
            background: rgba(31, 41, 55, 0.3);
            border-radius: 0.5rem;
            color: rgba(255, 255, 255, 0.5);
        }
        
        .add-card-section {
            margin-top: 2rem;
            padding: 1rem;
            background: rgba(31, 41, 55, 0.3);
            border-radius: 0.5rem;
            display: none;
        }
        
        .add-card-section.show {
            display: block;
        }
        
        .add-card-results {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(80px, 1fr));
            gap: 0.5rem;
            max-height: 200px;
            overflow-y: auto;
            padding: 0.5rem;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 0.5rem;
            margin-top: 0.5rem;
        }
        
        .add-card-result {
            cursor: pointer;
            transition: transform 0.2s;
            border-radius: 0.25rem;
            overflow: hidden;
        }
        
        .add-card-result:hover {
            transform: scale(1.1);
            z-index: 10;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
        }
        
        .add-card-result img {
            width: 100%;
            height: auto;
            display: block;
        }
        
        .edit-mode-indicator {
            background: linear-gradient(135deg, #f59e0b 0%, #f97316 100%);
            color: white;
            padding: 0.5rem 1rem;
            border-radius: 0.5rem;
            margin-bottom: 1rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
    </style>
</head>
<body class="min-h-screen bg-base-100">
    <!-- Header -->
    <div class="navbar bg-base-200 border-b border-base-300 fixed top-0 z-50">
        <div class="navbar-start">
            <div class="text-xl font-bold">
                <span class="text-primary">Card</span><span>Cast</span>
            </div>
            <div class="badge badge-primary badge-sm ml-2">v1.0.0</div>
        </div>
        <div class="navbar-end">
            <div id="obsStatus" class="badge badge-error gap-2">
                <div class="w-2 h-2 rounded-full bg-current status-indicator"></div>
                <span class="status-text">OBS Not Connected</span>
            </div>
        </div>
    </div>

    <!-- Main Container -->
    <div class="max-w-full px-4 pt-20 pb-8">
        <div class="grid grid-cols-1 lg:grid-cols-12 gap-4">
            
            <!-- Left Sidebar - Games Panel -->
            <aside class="col-span-12 lg:col-span-3 xl:col-span-2">
                <div class="card bg-base-200">
                    <div class="card-body p-4">
                        <h2 class="text-sm font-semibold opacity-60 uppercase tracking-wider">Select Game</h2>
                        
                        <div class="space-y-2" id="gamesList">
                            <!-- Games will be populated here by JavaScript -->
                        </div>
                        
                        <div class="divider my-3"></div>
                        
                        <h3 class="text-sm font-semibold opacity-60 uppercase tracking-wider">Download Options</h3>
                        <div class="form-control space-y-1">
                            <label class="label cursor-pointer justify-start gap-3 py-1">
                                <input type="radio" name="sets" value="1" class="radio radio-primary radio-sm" checked />
                                <span class="label-text text-sm">Most recent set only</span>
                            </label>
                            <label class="label cursor-pointer justify-start gap-3 py-1">
                                <input type="radio" name="sets" value="3" class="radio radio-primary radio-sm" />
                                <span class="label-text text-sm">Last 3 sets</span>
                            </label>
                            <label class="label cursor-pointer justify-start gap-3 py-1">
                                <input type="radio" name="sets" value="5" class="radio radio-primary radio-sm" />
                                <span class="label-text text-sm">Last 5 sets</span>
                            </label>
                            <label class="label cursor-pointer justify-start gap-3 py-1">
                                <input type="radio" name="sets" value="10" class="radio radio-primary radio-sm" />
                                <span class="label-text text-sm">Last 10 sets</span>
                            </label>
                            <label class="label cursor-pointer justify-start gap-3 py-1">
                                <input type="radio" name="sets" value="all" class="radio radio-primary radio-sm" />
                                <span class="label-text text-sm">All available sets</span>
                            </label>
                        </div>
                    </div>
                </div>
            </aside>

            <!-- Center - Search Section -->
            <main class="col-span-12 lg:col-span-6 xl:col-span-7">
                <!-- Search Bar -->
                <div class="card bg-base-200 mb-4">
                    <div class="card-body p-4">
                        <div class="join w-full">
                            <input 
                                type="text" 
                                id="searchInput"
                                placeholder="Select a game and download data to search..." 
                                class="input input-bordered join-item flex-1"
                                disabled
                            />
                            <button class="btn btn-square join-item" id="searchButton">
                                <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z" />
                                </svg>
                            </button>
                        </div>
                        <!-- Toggle for deck view mode -->
                        <div id="deckViewToggle" class="hidden mt-2">
                            <button class="btn btn-sm btn-ghost" onclick="exitDeckView()">
                                ← Back to Search
                            </button>
                        </div>
                    </div>
                </div>
                
                <!-- Search Results / Deck View -->
                <div class="card bg-base-200 min-h-[700px]" id="mainContentCard">
                    <div class="card-body p-4">
                        <div id="searchResults">
                            <div class="flex flex-col items-center justify-center py-20">
                                <div class="text-6xl mb-4">📦</div>
                                <p class="text-base-content/60">Select a game and download card data to begin</p>
                            </div>
                        </div>
                        
                        <!-- Deck View (hidden by default) -->
                        <div id="deckView" class="hidden">
                            <!-- Deck content will be populated here -->
                        </div>
                    </div>
                </div>
            </main>

            <!-- Right Sidebar - Deck Management -->
            <aside class="col-span-12 lg:col-span-3 space-y-4">
                <!-- Match Control Links -->
                <div class="card bg-base-200">
                    <div class="card-body p-4">
                        <h2 class="text-sm font-semibold opacity-60 uppercase tracking-wider">Match Controls</h2>
                        
                        <div class="space-y-2 mt-3">
                            <button onclick="window.open('/pokemon-match-control', '_blank')" class="btn btn-sm btn-primary w-full" id="pokemonMatchBtn" style="display: none;">
                                ⚡ Pokemon Match Control
                            </button>
                            
                            <p class="text-xs text-center opacity-40" id="noGameSelected">
                                Select a game to access match controls
                            </p>
                        </div>
                    </div>
                </div>
                
                <!-- Saved Decks -->
                <div class="card bg-base-200">
                    <div class="card-body p-4">
                        <h2 class="text-sm font-semibold opacity-60 uppercase tracking-wider">Saved Decks</h2>
                        
                        <div id="savedDecksList" class="space-y-2 mt-3">
                            <p class="text-xs text-center opacity-40">No decks saved yet</p>
                        </div>
                        
                        <button class="btn btn-sm btn-outline w-full mt-3" onclick="exportAllDecks()">
                            Export All Decks
                        </button>
                    </div>
                </div>

                <!-- Deck Import -->
                <div class="card bg-base-200">
                    <div class="card-body p-4">
                        <h2 class="text-sm font-semibold opacity-60 uppercase tracking-wider">Import Deck</h2>
                        
                        <input 
                            type="text"
                            id="deckNameInput"
                            class="input input-bordered input-sm w-full mt-2"
                            placeholder="Deck Name (e.g., Gardevoir ex)"
                        />
                        
                        <select id="deckGameSelect" class="select select-bordered select-sm w-full mt-2">
                            <option value="">Select game for this deck</option>
                            <option value="pokemon">Pokemon</option>
                            <option value="magic">Magic: The Gathering</option>
                            <option value="yugioh">Yu-Gi-Oh!</option>
                            <option value="lorcana">Disney Lorcana</option>
                            <option value="onepiece">One Piece</option>
                        </select>
                        
                        <textarea 
                            id="deckImportText"
                            class="textarea textarea-bordered textarea-sm w-full mt-2"
                            rows="6"
                            placeholder="Paste deck list here (Limitless TCG, PTCGL, or simple card names)..."
                        ></textarea>
                        
                        <div class="join w-full mt-2">
                            <button class="btn btn-sm btn-primary join-item flex-1" onclick="importAndSaveDeck()">Import & Save</button>
                            <button class="btn btn-sm join-item flex-1" onclick="clearDeckImport()">Clear</button>
                        </div>
                        
                        <div class="divider my-2"></div>
                        
                        <p class="text-xs font-semibold opacity-60 uppercase tracking-wider">Quick Search Deck</p>
                        <div class="form-control mt-2">
                            <label class="label cursor-pointer">
                                <span class="label-text text-sm">Search imported cards only</span>
                                <input type="checkbox" id="searchDeckOnly" class="checkbox checkbox-primary checkbox-sm" />
                            </label>
                        </div>
                    </div>
                </div>

                <!-- OBS Links -->
                <div class="card bg-base-200">
                    <div class="card-body p-4">
                        <h2 class="text-sm font-semibold opacity-60 uppercase tracking-wider">OBS Browser Sources</h2>
                        
                        <div class="space-y-2 mt-3">
                            <div class="bg-base-300 p-2 rounded-lg">
                                <div class="flex justify-between items-center">
                                    <div class="min-w-0">
                                        <p class="text-xs opacity-60">Main Overlay</p>
                                        <p class="text-xs font-mono truncate" id="obsMainUrl">http://localhost:3888/overlay</p>
                                    </div>
                                    <button class="btn btn-ghost btn-xs copy-btn" data-copy="obsMainUrl">Copy</button>
                                </div>
                            </div>
                            
                            <div class="bg-base-300 p-2 rounded-lg">
                                <div class="flex justify-between items-center">
                                    <div class="min-w-0">
                                        <p class="text-xs opacity-60">Pokemon Match</p>
                                        <p class="text-xs font-mono truncate" id="obsPokemonUrl">http://localhost:3888/pokemon-match</p>
                                    </div>
                                    <button class="btn btn-ghost btn-xs copy-btn" data-copy="obsPokemonUrl">Copy</button>
                                </div>
                            </div>
                            
                            <div class="bg-base-300 p-2 rounded-lg">
                                <div class="flex justify-between items-center">
                                    <div class="min-w-0">
                                        <p class="text-xs opacity-60">Prize Cards</p>
                                        <p class="text-xs font-mono truncate" id="obsPrizesUrl">http://localhost:3888/prizes</p>
                                    </div>
                                    <button class="btn btn-ghost btn-xs copy-btn" data-copy="obsPrizesUrl">Copy</button>
                                </div>
                            </div>
                            
                            <div class="bg-base-300 p-2 rounded-lg">
                                <div class="flex justify-between items-center">
                                    <div class="flex justify-between items-center w-full">
                                        <div class="min-w-0">
                                            <p class="text-xs opacity-60">Deck List</p>
                                            <p class="text-xs font-mono truncate" id="obsDecklistUrl">http://localhost:3888/decklist</p>
                                        </div>
                                        <button class="btn btn-ghost btn-xs copy-btn" data-copy="obsDecklistUrl">Copy</button>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Recent Cards -->
                <div class="card bg-base-200">
                    <div class="card-body p-4">
                        <h2 class="text-sm font-semibold opacity-60 uppercase tracking-wider">Recent Cards</h2>
                        <div class="flex gap-2 flex-wrap mt-2" id="recentCards">
                            <!-- Recent cards will appear here -->
                        </div>
                    </div>
                </div>
            </aside>
        </div>
    </div>

    <!-- Download Progress Toast -->
    <div class="toast toast-end">
        <div class="alert alert-info hidden" id="downloadProgress">
            <span class="loading loading-spinner"></span>
            <div>
                <div class="text-sm font-semibold">Downloading...</div>
                <div class="text-xs" id="progressText">0%</div>
                <progress class="progress progress-primary w-32" id="progressFill" value="0" max="100"></progress>
            </div>
        </div>
    </div>

    <!-- Socket.io -->
    <script src="/socket.io/socket.io.js"></script>
    <!-- Main JavaScript -->
    <script src="/js/main.js"></script>
    
    <script>
        // Deck management system
        let savedDecks = JSON.parse(localStorage.getItem('savedDecks')) || {};
        let currentImportedDeck = null;
        let isDeckViewMode = false;
        let currentViewedDeck = null;
        let isEditMode = false;
        let editingDeck = null;
        let draggedCard = null;
        let draggedFromCategory = null;
        let draggedFromIndex = null;
        
        // Pokemon Set Resolver using database mappings
        class PokemonSetResolver {
            constructor() {
                this.abbreviationToName = new Map();
                this.initialized = false;
            }

            async initialize() {
                if (this.initialized) return;
                
                try {
                    // Fetch set mappings from your database
                    const response = await fetch('/api/pokemon/set-mappings');
                    const mappings = await response.json();
                    
                    // Store all mappings
                    Object.entries(mappings).forEach(([abbrev, name]) => {
                        this.abbreviationToName.set(abbrev.toUpperCase(), name);
                    });
                    
                    console.log(`Loaded ${this.abbreviationToName.size} set mappings from database`);
                } catch (error) {
                    console.warn('Could not load set mappings from database:', error);
                    // Add minimal fallbacks for newest sets
                    this.addFallbackMappings();
                }
                
                this.initialized = true;
            }

            addFallbackMappings() {
                // Only essential fallbacks for newest sets that might not be in DB yet
                const fallbacks = {
                    'SCR': 'Stellar Crown',
                    'SFA': 'Shrouded Fable',
                    'TWM': 'Twilight Masquerade',
                    'TEF': 'Temporal Forces',
                    'PAR': 'Paradox Rift',
                    'MEW': '151',
                    'PAL': 'Paldea Evolved',
                    'SVI': 'Scarlet & Violet',
                    'SSP': 'Scarlet & Violet Black Star Promos',
                    'PRE': 'Paldean Fates',
                    'SVE': 'Scarlet & Violet Energies',
                    'JTG': 'Journey Together',
                    'OBF': 'Obsidian Flames'
                };
                
                Object.entries(fallbacks).forEach(([code, name]) => {
                    if (!this.abbreviationToName.has(code)) {
                        this.abbreviationToName.set(code, name);
                    }
                });
            }

            resolveSetCode(code) {
                if (!code) return null;
                return this.abbreviationToName.get(code.toUpperCase()) || code;
            }
        }

        // Create global instance
        const pokemonSetResolver = new PokemonSetResolver();
        
        // Helper function to detect trainer cards
        function isTrainerCard(cardName) {
            const trainerKeywords = [
                "Boss's Orders", "Professor", "Ultra Ball", "Nest Ball", "Iono",
                "Crispin", "Cyrano", "Briar", "Poffin", "Counter Catcher",
                "Super Rod", "Night Stretcher", "Tera Orb", "Crystal",
                "Balloon", "Area Zero", "Stadium", "Tool", "Supporter",
                "Item", "Ball", "Catcher", "Rod", "Stretcher", "Orb",
                "Buddy-Buddy", "Gravity Mountain", "Sparkling", "Air Balloon"
            ];
            
            const lowerName = cardName.toLowerCase();
            return trainerKeywords.some(keyword => lowerName.includes(keyword.toLowerCase()));
        }
        
        // Copy button functionality
        document.querySelectorAll('.copy-btn').forEach(btn => {
            btn.addEventListener('click', function() {
                const targetId = this.dataset.copy;
                const targetElement = document.getElementById(targetId);
                const text = targetElement.textContent;
                
                navigator.clipboard.writeText(text).then(() => {
                    const originalText = this.textContent;
                    this.textContent = 'Copied!';
                    setTimeout(() => {
                        this.textContent = originalText;
                    }, 2000);
                });
            });
        });
        
        // Update OBS status display
        window.updateOBSStatus = function(connected) {
            isOBSConnected = connected;
            const statusElement = document.getElementById('obsStatus');
            const statusText = statusElement.querySelector('.status-text');
            
            if (connected) {
                statusElement.classList.remove('badge-error');
                statusElement.classList.add('badge-success');
                statusText.textContent = 'OBS Connected';
            } else {
                statusElement.classList.remove('badge-success');
                statusElement.classList.add('badge-error');
                statusText.textContent = 'OBS Not Connected';
            }
        }
        
        // Override selectGame to show appropriate match control button
        const originalSelectGame = window.selectGame;
        window.selectGame = function(gameId, hasData) {
            // Call original function
            if (originalSelectGame) {
                originalSelectGame(gameId, hasData);
            }
            
            // Show/hide match control buttons based on game
            document.getElementById('pokemonMatchBtn').style.display = gameId === 'pokemon' ? 'block' : 'none';
            document.getElementById('noGameSelected').style.display = gameId ? 'none' : 'block';
            
            // Update deck game selector
            document.getElementById('deckGameSelect').value = gameId;
            
            // Update current game
            currentGame = gameId;
            
            // Exit deck view if in it
            if (isDeckViewMode) {
                exitDeckView();
            }
            
            // Update search based on deck filter
            if (document.getElementById('searchDeckOnly').checked && currentImportedDeck) {
                // Filter search to only deck cards
                updateSearchToDeckOnly();
            }
        }
        
        // Display deck view
        window.displayDeckView = async function(deck, game) {
            isDeckViewMode = true;
            currentViewedDeck = deck;
            editingDeck = JSON.parse(JSON.stringify(deck)); // Deep copy for editing
            
            // Update UI state
            document.getElementById('searchResults').classList.add('hidden');
            document.getElementById('deckView').classList.remove('hidden');
            document.getElementById('deckViewToggle').classList.remove('hidden');
            document.getElementById('mainContentCard').classList.add('deck-view-mode');
            document.getElementById('searchInput').disabled = true;
            
            // Render the deck
            await renderDeckView();
        }
        
        // Render deck view
        window.renderDeckView = async function() {
            const deck = editingDeck || currentViewedDeck;
            const game = deck.game;
            
            // Calculate totals
            const pokemonCount = deck.pokemon?.reduce((sum, c) => sum + c.quantity, 0) || 0;
            const trainerCount = deck.trainers?.reduce((sum, c) => sum + c.quantity, 0) || 0;
            const energyCount = deck.energy?.reduce((sum, c) => sum + c.quantity, 0) || 0;
            const totalCards = pokemonCount + trainerCount + energyCount;
            
            // Build deck view HTML
            let deckHTML = `
                <div class="deck-view-header">
                    <div class="deck-info">
                        ${isEditMode ? 
                            `<input type="text" class="deck-name-input" id="deckNameEdit" value="${deck.name}" />` :
                            `<div class="deck-name">${deck.name}</div>`
                        }
                        <div class="deck-stats">
                            <div class="deck-stat">
                                <span>📦</span>
                                <span>${totalCards} cards</span>
                            </div>
                            <div class="deck-stat">
                                <span>🎮</span>
                                <span>${game.charAt(0).toUpperCase() + game.slice(1)}</span>
                            </div>
                        </div>
                    </div>
                    <div class="deck-actions">
                        ${isEditMode ? `
                            <button class="btn btn-sm btn-success" onclick="saveDeckEdits()">Save Changes</button>
                            <button class="btn btn-sm btn-warning" onclick="cancelDeckEdit()">Cancel</button>
                        ` : `
                            <button class="btn btn-sm btn-primary" onclick="sendDeckToOverlay()">Send to Overlay</button>
                            <button class="btn btn-sm btn-secondary" onclick="enterEditMode()">Edit Deck</button>
                            <button class="btn btn-sm btn-ghost" onclick="exitDeckView()">Close</button>
                        `}
                    </div>
                </div>
            `;
            
            // Add edit mode indicator
            if (isEditMode) {
                deckHTML += `
                    <div class="edit-mode-indicator">
                        <span>✏️</span>
                        <span>Edit Mode - Drag cards to reorder or move between sections</span>
                    </div>
                `;
            }
            
            // Add Pokemon section
            const pokemonCards = deck.pokemon || [];
            deckHTML += `
                <div class="deck-section">
                    <div class="deck-section-header">
                        <span class="deck-section-title">Pokémon</span>
                        <span class="deck-section-count">${pokemonCount}</span>
                    </div>
                    <div class="deck-card-grid" id="pokemon-grid" 
                         ${isEditMode ? 'ondragover="handleDragOver(event)" ondragleave="handleDragLeave(event)" ondrop="handleDrop(event, \'pokemon\')"' : ''}>
                        ${pokemonCards.length > 0 ? await renderDeckCards(pokemonCards, game, 'pokemon') : 
                          (isEditMode ? '<div class="empty-section">Drop Pokémon cards here</div>' : '')}
                    </div>
                </div>
            `;
            
            // Add Trainers section
            const trainerCards = deck.trainers || [];
            deckHTML += `
                <div class="deck-section">
                    <div class="deck-section-header">
                        <span class="deck-section-title">Trainers</span>
                        <span class="deck-section-count">${trainerCount}</span>
                    </div>
                    <div class="deck-card-grid" id="trainers-grid"
                         ${isEditMode ? 'ondragover="handleDragOver(event)" ondragleave="handleDragLeave(event)" ondrop="handleDrop(event, \'trainers\')"' : ''}>
                        ${trainerCards.length > 0 ? await renderDeckCards(trainerCards, game, 'trainers') : 
                          (isEditMode ? '<div class="empty-section">Drop Trainer cards here</div>' : '')}
                    </div>
                </div>
            `;
            
            // Add Energy section
            const energyCards = deck.energy || [];
            deckHTML += `
                <div class="deck-section">
                    <div class="deck-section-header">
                        <span class="deck-section-title">Energy</span>
                        <span class="deck-section-count">${energyCount}</span>
                    </div>
                    <div class="deck-card-grid" id="energy-grid"
                         ${isEditMode ? 'ondragover="handleDragOver(event)" ondragleave="handleDragLeave(event)" ondrop="handleDrop(event, \'energy\')"' : ''}>
                        ${energyCards.length > 0 ? await renderDeckCards(energyCards, game, 'energy') : 
                          (isEditMode ? '<div class="empty-section">Drop Energy cards here</div>' : '')}
                    </div>
                </div>
            `;
            
            // Add card search section if in edit mode
            if (isEditMode) {
                deckHTML += `
                    <div class="add-card-section show">
                        <h3 class="text-lg font-semibold mb-3">Add Cards</h3>
                        <div class="flex gap-2 mb-3">
                            <input type="text" 
                                   id="addCardSearch" 
                                   class="input input-bordered flex-1" 
                                   placeholder="Search for cards to add..."
                                   onkeyup="searchCardsToAdd(event)">
                            <select id="addCardCategory" class="select select-bordered">
                                <option value="pokemon">Pokémon</option>
                                <option value="trainers">Trainers</option>
                                <option value="energy">Energy</option>
                            </select>
                        </div>
                        <div id="addCardResults" class="add-card-results">
                            <!-- Search results will appear here -->
                        </div>
                    </div>
                `;
            }
            
            document.getElementById('deckView').innerHTML = deckHTML;
        }
        
        // Enhanced render deck cards with set resolution
        async function renderDeckCards(cards, game, category) {
            let cardsHTML = '';
            
            for (let i = 0; i < cards.length; i++) {
                const card = cards[i];
                let cardImage = '/images/card-back.png';
                
                try {
                    let searchQuery = '';
                    
                    if (card.setCode && card.cardNumber) {
                        searchQuery = `${card.name} ${card.setCode.toUpperCase()} ${card.cardNumber}`;
                    } else if (card.setCode) {
                        searchQuery = `${card.name} ${card.setCode.toUpperCase()}`;
                    } else {
                        searchQuery = card.name;
                    }
                    
                    const response = await fetch(`/api/search/${game}?q=${encodeURIComponent(searchQuery)}`);
                    const results = await response.json();
                    
                    if (results.length > 0) {
                        // Try to find exact match
                        let matchedCard = null;
                        if (card.setCode && card.cardNumber) {
                            matchedCard = results.find(r => 
                                r.set_abbreviation === card.setCode.toUpperCase() && 
                                r.card_number === card.cardNumber
                            );
                        }
                        
                        if (!matchedCard) {
                            matchedCard = results[0];
                        }
                        
                        if (matchedCard) {
                            // Simply use image_url which already has the correct /cache/images/... path
                            cardImage = matchedCard.image_url || cardImage;
                        }
                    }
                } catch (error) {
                    console.error(`Error fetching card image for ${card.name}:`, error);
                }
                
                const cardTitle = card.setCode ? 
                    `${card.name} (${card.setCode} ${card.cardNumber || ''})` : 
                    card.name;
                
                if (isEditMode) {
                    cardsHTML += `
                        <div class="deck-card-item edit-mode" 
                            draggable="true"
                            ondragstart="handleCardDragStart(event, '${category}', ${i})"
                            ondragend="handleCardDragEnd(event)"
                            ondragover="event.preventDefault()"
                            data-category="${category}"
                            data-index="${i}"
                            title="${cardTitle}">
                            <div class="deck-card-controls">
                                <button class="deck-card-control-btn" onclick="event.stopPropagation(); adjustCardQuantity('${category}', ${i}, -1)">−</button>
                                <span style="color: white; font-size: 0.875rem;">${card.quantity}</span>
                                <button class="deck-card-control-btn" onclick="event.stopPropagation(); adjustCardQuantity('${category}', ${i}, 1)">+</button>
                                <button class="deck-card-control-btn remove" onclick="event.stopPropagation(); removeCardFromDeck('${category}', ${i})">×</button>
                            </div>
                            <img src="${cardImage}" alt="${cardTitle}" class="deck-card-image" draggable="false" />
                            ${card.quantity > 1 ? `<div class="deck-card-quantity">${card.quantity}</div>` : ''}
                        </div>
                    `;
                } else {
                    cardsHTML += `
                        <div class="deck-card-item" title="${cardTitle}">
                            <img src="${cardImage}" alt="${cardTitle}" class="deck-card-image" />
                            ${card.quantity > 1 ? `<div class="deck-card-quantity">${card.quantity}</div>` : ''}
                        </div>
                    `;
                }
            }
            
            return cardsHTML;
        }

        // parseDeckList function with proper parsing
        window.parseDeckList = async function(text) {
            // Ensure resolver is initialized
            if (typeof pokemonSetResolver !== 'undefined') {
                await pokemonSetResolver.initialize();
            }
            
            const lines = text.split('\n').filter(line => line.trim());
            const deck = {
                pokemon: [],
                trainers: [],
                energy: []
            };
            
            let currentSection = null;
            
            for (const line of lines) {
                const trimmed = line.trim();
                
                // Skip empty lines and total count lines
                if (!trimmed || trimmed.match(/^Total:\s*\d+$/i) || trimmed.match(/^Total Cards:\s*\d+$/i)) {
                    continue;
                }
                
                // Check for section headers
                if (trimmed.match(/^Pok[eé]mon:\s*\d*$/i)) {
                    currentSection = 'pokemon';
                    continue;
                } else if (trimmed.match(/^Trainer:\s*\d*$/i)) {
                    currentSection = 'trainers';
                    continue;
                } else if (trimmed.match(/^Energy:\s*\d*$/i)) {
                    currentSection = 'energy';
                    continue;
                }
                
                // Auto-detect section if not set
                if (!currentSection) {
                    if (trimmed.toLowerCase().includes('energy')) {
                        currentSection = 'energy';
                    } else if (isTrainerCard(trimmed)) {
                        currentSection = 'trainers';
                    } else if (trimmed.match(/\d+\s+.+\s+[A-Z]{2,4}\s+\d+/)) {
                        currentSection = 'pokemon';
                    }
                }
                
                if (!currentSection) continue;
                
                // Parse card lines
                let cardData = null;
                
                // Special handling for PTCGL energy format: "3 Basic {D} Energy SVE 15"
                if (trimmed.includes('{') && trimmed.includes('Energy')) {
                    const energyMatch = trimmed.match(/^(\d+)\s+Basic\s+\{([A-Z])\}\s+Energy\s+([A-Z]{2,4})\s+(\d+)$/);
                    if (energyMatch) {
                        const [_, quantity, type, setCode, number] = energyMatch;
                        
                        // Convert type letter to full name
                        const types = {
                            'P': 'Psychic',
                            'D': 'Darkness', 
                            'F': 'Fighting',
                            'R': 'Fire',
                            'W': 'Water',
                            'L': 'Lightning',
                            'G': 'Grass',
                            'M': 'Metal',
                            'C': 'Colorless',
                            'N': 'Dragon',
                            'Y': 'Fairy'
                        };
                        
                        const energyName = `${types[type] || type} Energy`;
                        
                        cardData = {
                            quantity: parseInt(quantity),
                            name: energyName,
                            setCode: setCode.toUpperCase(),
                            cardNumber: number,
                            fullName: `${energyName} ${setCode} ${number}`
                        };
                        
                        currentSection = 'energy'; // Force to energy section
                    }
                }
                
                // If not matched as PTCGL energy, try standard patterns
                if (!cardData) {
                    // Pattern 1: "4 Hoothoot SCR 114" - standard format with set and number
                    let match = trimmed.match(/^(\d+)\s+(.+?)\s+([A-Z]{2,4})\s+(\d+)$/);
                    if (match) {
                        let [_, quantity, name, setCode, number] = match;
                        
                        cardData = {
                            quantity: parseInt(quantity),
                            name: name.trim(),
                            setCode: setCode.toUpperCase(),
                            cardNumber: number,
                            fullName: `${name.trim()} ${setCode} ${number}`
                        };
                        
                        // Add set name if resolver is available
                        if (typeof pokemonSetResolver !== 'undefined') {
                            cardData.setName = pokemonSetResolver.resolveSetCode(setCode);
                        }
                        
                        // Auto-correct section based on card type
                        if (name.toLowerCase().includes('energy')) {
                            currentSection = 'energy';
                        } else if (isTrainerCard(name)) {
                            currentSection = 'trainers';
                        }
                        
                    } else {
                        // Pattern 2: "4 Professor's Research" - just quantity and name
                        match = trimmed.match(/^(\d+)\s+(.+)$/);
                        if (match) {
                            let [_, quantity, fullName] = match;
                            
                            // Check if the name contains a set code at the end
                            const setMatch = fullName.match(/^(.+?)\s+([A-Z]{2,4})$/);
                            if (setMatch) {
                                const [__, name, setCode] = setMatch;
                                cardData = {
                                    quantity: parseInt(quantity),
                                    name: name.trim(),
                                    setCode: setCode.toUpperCase(),
                                    fullName: fullName
                                };
                            } else {
                                cardData = {
                                    quantity: parseInt(quantity),
                                    name: fullName.trim(),
                                    fullName: fullName.trim()
                                };
                            }
                            
                            // Auto-correct section
                            if (fullName.toLowerCase().includes('energy')) {
                                currentSection = 'energy';
                            } else if (isTrainerCard(fullName)) {
                                currentSection = 'trainers';
                            }
                        }
                    }
                }
                
                // Add the card to the appropriate section
                if (cardData) {
                    deck[currentSection].push(cardData);
                    console.log(`Parsed ${currentSection}:`, cardData);
                }
            }
            
            console.log('Deck parsing complete:', {
                pokemon: deck.pokemon.length + ' unique cards',
                trainers: deck.trainers.length + ' unique cards', 
                energy: deck.energy.length + ' unique cards',
                total: deck.pokemon.reduce((sum, c) => sum + c.quantity, 0) +
                    deck.trainers.reduce((sum, c) => sum + c.quantity, 0) +
                    deck.energy.reduce((sum, c) => sum + c.quantity, 0) + ' total cards'
            });
            
            return deck;
        }
        
        // Handle card drag start
        window.handleCardDragStart = function(event, category, index) {
            if (!editingDeck || !editingDeck[category] || !editingDeck[category][index]) {
                console.error('Invalid drag start:', category, index);
                return;
            }
            
            draggedCard = editingDeck[category][index];
            draggedFromCategory = category;
            draggedFromIndex = index;
            event.target.classList.add('dragging');
            event.dataTransfer.effectAllowed = 'move';
            event.dataTransfer.setData('text/plain', ''); // Required for Firefox
            
            console.log('Dragging card:', draggedCard.name, 'from', category, 'index', index);
        }
        
        // Handle card drag end
        window.handleCardDragEnd = function(event) {
            event.target.classList.remove('dragging');
            
            // Remove all drag-over classes
            document.querySelectorAll('.drag-over').forEach(el => {
                el.classList.remove('drag-over');
            });
        }
        
        // Handle drag over
        window.handleDragOver = function(event) {
            event.preventDefault();
            event.dataTransfer.dropEffect = 'move';
            
            const grid = event.currentTarget;
            grid.classList.add('drag-over');
        }
        
        // Handle drag leave
        window.handleDragLeave = function(event) {
            event.currentTarget.classList.remove('drag-over');
        }
        
        // Handle drop
        window.handleDrop = function(event, targetCategory) {
            event.preventDefault();
            event.currentTarget.classList.remove('drag-over');
            
            if (!draggedCard || !draggedFromCategory || draggedFromIndex === null) return;
            
            // Initialize category arrays if they don't exist
            if (!editingDeck[targetCategory]) {
                editingDeck[targetCategory] = [];
            }
            if (!editingDeck[draggedFromCategory]) {
                editingDeck[draggedFromCategory] = [];
            }
            
            // Find the target position
            const targetElement = event.target.closest('.deck-card-item');
            let targetIndex = editingDeck[targetCategory].length; // Default to end
            
            if (targetElement && targetElement.dataset.category === targetCategory) {
                targetIndex = parseInt(targetElement.dataset.index) || 0;
                
                // Determine if we're dropping before or after
                const rect = targetElement.getBoundingClientRect();
                const midpoint = rect.left + rect.width / 2;
                if (event.clientX > midpoint) {
                    targetIndex++;
                }
            }
            
            // If moving within same category
            if (draggedFromCategory === targetCategory) {
                // Remove from original position
                const [removed] = editingDeck[draggedFromCategory].splice(draggedFromIndex, 1);
                
                // Adjust target index if necessary
                if (targetIndex > draggedFromIndex) {
                    targetIndex--;
                }
                
                // Insert at new position
                editingDeck[targetCategory].splice(targetIndex, 0, removed);
            } else {
                // Moving to different category
                // Remove from original category
                const [removed] = editingDeck[draggedFromCategory].splice(draggedFromIndex, 1);
                
                // Add to new category
                editingDeck[targetCategory].splice(targetIndex, 0, removed);
            }
            
            // Reset drag state
            draggedCard = null;
            draggedFromCategory = null;
            draggedFromIndex = null;
            
            // Re-render
            renderDeckView();
        }
        
        // Enter edit mode
        window.enterEditMode = function() {
            isEditMode = true;
            editingDeck = JSON.parse(JSON.stringify(currentViewedDeck)); // Deep copy
            renderDeckView();
        }
        
        // Cancel deck edit
        window.cancelDeckEdit = function() {
            isEditMode = false;
            editingDeck = null;
            renderDeckView();
        }
        
        // Save deck edits
        window.saveDeckEdits = function() {
            const newName = document.getElementById('deckNameEdit').value.trim();
            if (!newName) {
                alert('Deck name cannot be empty');
                return;
            }
            
            // Update deck name
            editingDeck.name = newName;
            
            // Find and update the deck in savedDecks
            const game = editingDeck.game;
            const oldName = currentViewedDeck.name;
            
            if (savedDecks[game]) {
                const deckIndex = savedDecks[game].findIndex(d => d.name === oldName);
                if (deckIndex > -1) {
                    savedDecks[game][deckIndex] = editingDeck;
                    localStorage.setItem('savedDecks', JSON.stringify(savedDecks));
                    
                    // Update current viewed deck
                    currentViewedDeck = JSON.parse(JSON.stringify(editingDeck));
                    currentImportedDeck = currentViewedDeck;
                    
                    // Exit edit mode
                    isEditMode = false;
                    editingDeck = null;
                    
                    // Update UI
                    updateSavedDecksList();
                    renderDeckView();
                    
                    alert('Deck saved successfully!');
                }
            }
        }
        
        // Adjust card quantity
        window.adjustCardQuantity = function(category, index, delta) {
            const card = editingDeck[category][index];
            card.quantity = Math.max(1, Math.min(4, card.quantity + delta)); // Min 1, Max 4
            renderDeckView();
        }
        
        // Remove card from deck
        window.removeCardFromDeck = function(category, index) {
            editingDeck[category].splice(index, 1);
            renderDeckView();
        }
        
        // Search cards to add
        window.searchCardsToAdd = async function(event) {
            const query = event.target.value.trim();
            if (query.length < 2) {
                document.getElementById('addCardResults').innerHTML = '';
                return;
            }
            
            const game = editingDeck.game;
            
            try {
                const response = await fetch(`/api/search/${game}?q=${encodeURIComponent(query)}`);
                const results = await response.json();
                
                const resultsHTML = results.slice(0, 24).map(card => `
                    <div class="add-card-result" 
                         onclick="addCardToDeck('${escape(card.name)}', '${card.display_image || card.local_image || card.image_url || '/images/card-back.png'}')">
                        <img src="${card.display_image || card.local_image || card.image_url || '/images/card-back.png'}" 
                             alt="${card.name}"
                             title="${card.name}">
                    </div>
                `).join('');
                
                document.getElementById('addCardResults').innerHTML = resultsHTML || '<p class="col-span-full text-center opacity-50">No cards found</p>';
            } catch (error) {
                console.error('Error searching cards:', error);
            }
        }
        
        // Add card to deck
        window.addCardToDeck = function(cardName, cardImage) {
            // Unescape the card name
            cardName = cardName.replace(/\\'/g, "'").replace(/\\"/g, '"');
            
            const category = document.getElementById('addCardCategory').value;
            
            // Initialize category if it doesn't exist
            if (!editingDeck[category]) {
                editingDeck[category] = [];
            }
            
            // Check if card already exists in the category
            const existingCard = editingDeck[category].find(c => c.name === cardName);
            
            if (existingCard) {
                // Increase quantity (max 4)
                if (existingCard.quantity < 4) {
                    existingCard.quantity++;
                } else {
                    alert('Maximum 4 copies of a card allowed');
                    return;
                }
            } else {
                // Add new card
                editingDeck[category].push({
                    name: cardName,
                    quantity: 1
                });
            }
            
            // Clear search
            document.getElementById('addCardSearch').value = '';
            document.getElementById('addCardResults').innerHTML = '';
            
            // Re-render deck
            renderDeckView();
        }
        
        // Select card from deck view
        window.selectCardFromDeck = async function(cardName, game) {
            try {
                const response = await fetch(`/api/search/${game}?q=${encodeURIComponent(cardName)}`);
                const results = await response.json();
                
                if (results.length > 0) {
                    const exactMatch = results.find(r => r.name.toLowerCase() === cardName.toLowerCase());
                    const card = exactMatch || results[0];
                    
                    // Call the regular selectCard function
                    if (window.selectCard) {
                        window.selectCard(card.id);
                    }
                }
            } catch (error) {
                console.error('Error selecting card from deck:', error);
            }
        }
        
        // Exit deck view mode
        window.exitDeckView = function() {
            isDeckViewMode = false;
            currentViewedDeck = null;
            
            // Reset UI state
            document.getElementById('searchResults').classList.remove('hidden');
            document.getElementById('deckView').classList.add('hidden');
            document.getElementById('deckViewToggle').classList.add('hidden');
            document.getElementById('mainContentCard').classList.remove('deck-view-mode');
            
            // Re-enable search if game is selected
            if (currentGame) {
                document.getElementById('searchInput').disabled = false;
            }
            
            // Clear deck view content
            document.getElementById('deckView').innerHTML = '';
        }
        
        // Send deck to overlay
        window.sendDeckToOverlay = function() {
            if (!currentViewedDeck) return;
            
            // Send deck to decklist overlay
            if (window.socket) {
                window.socket.emit('decklist-update', {
                    deck: currentViewedDeck,
                    show: true
                });
                
                alert('Deck sent to overlay!');
            }
        }
        
        // Enhanced import and save deck with resolver
        window.importAndSaveDeck = async function() {
            const deckName = document.getElementById('deckNameInput').value.trim();
            const deckGame = document.getElementById('deckGameSelect').value;
            const deckText = document.getElementById('deckImportText').value.trim();
            
            if (!deckName) {
                alert('Please enter a deck name');
                return;
            }
            
            if (!deckGame) {
                alert('Please select a game for this deck');
                return;
            }
            
            if (!deckText) {
                alert('Please paste a deck list');
                return;
            }
            
            // Show loading indicator
            const importButton = event.target;
            const originalText = importButton.textContent;
            importButton.textContent = 'Importing...';
            importButton.disabled = true;
            
            try {
                // Parse the deck with resolver
                const deck = await parseDeckList(deckText);
                deck.name = deckName;
                deck.game = deckGame;
                deck.dateAdded = new Date().toISOString();
                
                // Save to localStorage
                if (!savedDecks[deckGame]) {
                    savedDecks[deckGame] = [];
                }
                
                // Check if deck with same name exists
                const existingIndex = savedDecks[deckGame].findIndex(d => d.name === deckName);
                if (existingIndex > -1) {
                    if (!confirm(`Deck "${deckName}" already exists. Replace it?`)) {
                        importButton.textContent = originalText;
                        importButton.disabled = false;
                        return;
                    }
                    savedDecks[deckGame][existingIndex] = deck;
                } else {
                    savedDecks[deckGame].push(deck);
                }
                
                localStorage.setItem('savedDecks', JSON.stringify(savedDecks));
                
                // Set as current imported deck
                currentImportedDeck = deck;
                
                // Update UI
                updateSavedDecksList();
                clearDeckImport();
                
                alert(`Deck "${deckName}" imported successfully!`);
                
            } catch (error) {
                console.error('Error importing deck:', error);
                alert('Error importing deck. Please check the format and try again.');
            } finally {
                importButton.textContent = originalText;
                importButton.disabled = false;
            }
        }
        
        // Update saved decks list
        window.updateSavedDecksList = function() {
            const listDiv = document.getElementById('savedDecksList');
            
            const allDecks = [];
            Object.keys(savedDecks).forEach(game => {
                savedDecks[game].forEach(deck => {
                    allDecks.push({ ...deck, game });
                });
            });
            
            if (allDecks.length === 0) {
                listDiv.innerHTML = '<p class="text-xs text-center opacity-40">No decks saved yet</p>';
                return;
            }
            
            listDiv.innerHTML = allDecks.map(deck => {
                const totalCards = 
                    (deck.pokemon?.reduce((sum, c) => sum + c.quantity, 0) || 0) +
                    (deck.trainers?.reduce((sum, c) => sum + c.quantity, 0) || 0) +
                    (deck.energy?.reduce((sum, c) => sum + c.quantity, 0) || 0);
                
                return `
                    <div class="bg-base-300 p-2 rounded-lg">
                        <div class="flex justify-between items-start">
                            <div class="min-w-0 flex-1">
                                <p class="font-semibold text-sm truncate">${deck.name}</p>
                                <p class="text-xs opacity-60">${deck.game} • ${totalCards} cards</p>
                            </div>
                            <div class="flex gap-1 ml-2">
                                <button class="btn btn-xs btn-ghost" onclick="loadDeck('${deck.game}', '${escape(deck.name)}')">View</button>
                                <button class="btn btn-xs btn-ghost" onclick="exportDeckToClipboard('${deck.game}', '${escape(deck.name)}')">📋</button>
                                <button class="btn btn-xs btn-error btn-ghost" onclick="deleteDeck('${deck.game}', '${escape(deck.name)}')">×</button>
                            </div>
                        </div>
                    </div>
                `;
            }).join('');
        }
        
        // Helper function to escape quotes in deck names
        window.escape = function(str) {
            return str.replace(/'/g, "\\'").replace(/\\"/g, '\\"');
        }
        
        // Load a saved deck
        window.loadDeck = function(game, deckName) {
            // Unescape the deck name
            deckName = deckName.replace(/\\'/g, "'").replace(/\\"/g, '"');
            
            const deck = savedDecks[game]?.find(d => d.name === deckName);
            if (!deck) return;
            
            currentImportedDeck = deck;
            
            // Switch to the deck's game if not already
            if (currentGame !== game) {
                selectGame(game, true);
            }
            
            // Display the deck view
            displayDeckView(deck, game);
        }
        
        // Delete a saved deck
        window.deleteDeck = function(game, deckName) {
            // Unescape the deck name
            deckName = deckName.replace(/\\'/g, "'").replace(/\\"/g, '"');
            
            if (!confirm(`Delete deck "${deckName}"?`)) return;
            
            savedDecks[game] = savedDecks[game].filter(d => d.name !== deckName);
            if (savedDecks[game].length === 0) {
                delete savedDecks[game];
            }
            
            localStorage.setItem('savedDecks', JSON.stringify(savedDecks));
            updateSavedDecksList();
        }
        
        // Export all decks
        window.exportAllDecksJSON = function() {
            const dataStr = JSON.stringify(savedDecks, null, 2);
            const dataUri = 'data:application/json;charset=utf-8,'+ encodeURIComponent(dataStr);
            
            const exportLink = document.createElement('a');
            exportLink.setAttribute('href', dataUri);
            exportLink.setAttribute('download', `cardcast-decks-${new Date().toISOString().split('T')[0]}.json`);
            document.body.appendChild(exportLink);
            exportLink.click();
            document.body.removeChild(exportLink);
        }

        window.exportAllDecks = function() {
            const choice = confirm('Export as JSON file?\n\nOK = JSON file (for backup)\nCancel = Copy individual deck to clipboard');
            
            if (choice) {
                exportAllDecksJSON();
            } else {
                alert('Click the 📋 button next to any deck to copy it to clipboard');
            }
        }

        // Export single deck to clipboard in standard format
        window.exportDeckToClipboard = function(game, deckName) {
            // Unescape the deck name if needed
            if (typeof deckName === 'string') {
                deckName = deckName.replace(/\\'/g, "'").replace(/\\"/g, '"');
            }
            
            const deck = savedDecks[game]?.find(d => d.name === deckName);
            if (!deck) {
                alert('Deck not found');
                return;
            }
            
            let deckText = '';
            
            // Calculate totals
            const pokemonCount = deck.pokemon?.reduce((sum, c) => sum + c.quantity, 0) || 0;
            const trainerCount = deck.trainers?.reduce((sum, c) => sum + c.quantity, 0) || 0;
            const energyCount = deck.energy?.reduce((sum, c) => sum + c.quantity, 0) || 0;
            const totalCards = pokemonCount + trainerCount + energyCount;
            
            // Add Pokemon section
            if (pokemonCount > 0) {
                deckText += `Pokémon: ${pokemonCount}\n`;
                deck.pokemon.forEach(card => {
                    if (card.setCode && card.cardNumber) {
                        deckText += `${card.quantity} ${card.name} ${card.setCode} ${card.cardNumber}\n`;
                    } else {
                        deckText += `${card.quantity} ${card.name}\n`;
                    }
                });
            }
            
            // Add Trainer section
            if (trainerCount > 0) {
                if (deckText) deckText += '\n';
                deckText += `Trainer: ${trainerCount}\n`;
                deck.trainers.forEach(card => {
                    if (card.setCode && card.cardNumber) {
                        deckText += `${card.quantity} ${card.name} ${card.setCode} ${card.cardNumber}\n`;
                    } else {
                        deckText += `${card.quantity} ${card.name}\n`;
                    }
                });
            }
            
            // Add Energy section
            if (energyCount > 0) {
                if (deckText) deckText += '\n';
                deckText += `Energy: ${energyCount}\n`;
                deck.energy.forEach(card => {
                    if (card.setCode && card.cardNumber) {
                        deckText += `${card.quantity} ${card.name} ${card.setCode} ${card.cardNumber}\n`;
                    } else {
                        deckText += `${card.quantity} ${card.name}\n`;
                    }
                });
            }
            
            // Add total
            deckText += `\nTotal Cards: ${totalCards}`;
            
            // Copy to clipboard
            navigator.clipboard.writeText(deckText).then(() => {
                // Show success message
                showToast(`Deck "${deck.name}" copied to clipboard!`);
            }).catch(err => {
                alert('Failed to copy to clipboard. Please try again.');
                console.error('Clipboard error:', err);
            });
        }

        // Add toast notification for success messages
        window.showToast = function(message) {
            // Check if toast container exists
            let toastContainer = document.getElementById('toast-container');
            if (!toastContainer) {
                toastContainer = document.createElement('div');
                toastContainer.id = 'toast-container';
                toastContainer.className = 'toast toast-top toast-end';
                document.body.appendChild(toastContainer);
            }
            
            // Create toast element
            const toast = document.createElement('div');
            toast.className = 'alert alert-success';
            toast.innerHTML = `
                <svg xmlns="http://www.w3.org/2000/svg" class="stroke-current shrink-0 h-6 w-6" fill="none" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z" />
                </svg>
                <span>${message}</span>
            `;
            
            toastContainer.appendChild(toast);
            
            // Remove toast after 3 seconds
            setTimeout(() => {
                toast.remove();
            }, 3000);
        }
        
        // Clear deck import
        window.clearDeckImport = function() {
            document.getElementById('deckNameInput').value = '';
            document.getElementById('deckImportText').value = '';
        }
        
        // Filter search to deck only
        window.updateSearchToDeckOnly = function() {
            if (!currentImportedDeck) return;
            
            // Get all card names from the deck
            const deckCardNames = new Set();
            ['pokemon', 'trainers', 'energy'].forEach(category => {
                if (currentImportedDeck[category]) {
                    currentImportedDeck[category].forEach(card => {
                        deckCardNames.add(card.name.toLowerCase());
                    });
                }
            });
            
            // Re-run search with deck filter
            const searchInput = document.getElementById('searchInput');
            if (searchInput.value) {
                handleSearch({ target: searchInput });
            }
        }
        
        // Override search to support deck filtering
        const originalHandleSearch = window.handleSearch;
        window.handleSearch = async function(event) {
            // Don't search if in deck view mode
            if (isDeckViewMode) return;
            
            const query = event.target.value.trim();
            
            if (!currentGame || query.length < 2) {
                clearSearchResults();
                return;
            }
            
            try {
                const response = await fetch(`/api/search/${currentGame}?q=${encodeURIComponent(query)}`);
                let results = await response.json();
                
                // Filter by deck if enabled
                if (document.getElementById('searchDeckOnly').checked && currentImportedDeck) {
                    const deckCardNames = new Set();
                    ['pokemon', 'trainers', 'energy'].forEach(category => {
                        if (currentImportedDeck[category]) {
                            currentImportedDeck[category].forEach(card => {
                                deckCardNames.add(card.name.toLowerCase());
                            });
                        }
                    });
                    
                    results = results.filter(card => 
                        deckCardNames.has(card.name.toLowerCase())
                    );
                }
                
                searchResults = results;
                displaySearchResults(results);
            } catch (error) {
                console.error('Search error:', error);
            }
        }
        
        // Display search results with DaisyUI cards
        window.displaySearchResults = function(results) {
            const resultsDiv = document.getElementById('searchResults');
            
            if (results.length === 0) {
                resultsDiv.innerHTML = `
                    <div class="flex flex-col items-center justify-center py-20">
                        <div class="text-6xl mb-4">🔍</div>
                        <h3 class="text-lg font-medium mb-1">No cards found</h3>
                        <p class="text-sm opacity-60">Try a different search term</p>
                    </div>
                `;
                return;
            }
            
            resultsDiv.innerHTML = `
                <div class="grid grid-cols-3 sm:grid-cols-4 lg:grid-cols-5 xl:grid-cols-6 gap-3">
                    ${results.map(card => `
                        <div class="cursor-pointer group card-result" onclick="selectCard('${card.id}')">
                            <div class="card-thumbnail">
                                <img 
                                    src="${card.display_image || card.local_image || card.image_url || '/images/card-back.png'}" 
                                    alt="${card.name}"
                                    class="w-full h-full object-cover rounded-lg group-hover:scale-105 transition-transform"
                                    loading="lazy"
                                />
                            </div>
                            <div class="mt-1">
                                <p class="text-sm font-medium truncate">${card.name}</p>
                                <p class="text-xs opacity-60">${card.set_name || ''} ${card.card_number ? '#' + card.card_number : ''}</p>
                            </div>
                        </div>
                    `).join('')}
                </div>
            `;
        }
        
        // Clear search results
        window.clearSearchResults = function() {
            document.getElementById('searchResults').innerHTML = `
                <div class="flex flex-col items-center justify-center py-20">
                    <div class="text-6xl mb-4">📦</div>
                    <p class="text-base-content/60">Select a game and download card data to begin</p>
                </div>
            `;
            searchResults = [];
        }
                
        // Update card preview with DaisyUI styling
        window.updateCardPreview = function(card) {
            const previewDiv = document.getElementById('cardPreview');
            
            if (!card) {
                previewDiv.innerHTML = `
                    <div class="aspect-[63/88] bg-base-300 rounded-lg flex items-center justify-center">
                        <div class="text-center">
                            <div class="text-4xl mb-2">🎴</div>
                            <span class="text-base-content/40">No card selected</span>
                        </div>
                    </div>
                `;
                return;
            }
            
            previewDiv.innerHTML = `
                <div class="space-y-3">
                    <div class="aspect-[63/88] rounded-lg overflow-hidden bg-base-300">
                        <img 
                            src="${card.display_image || card.local_image || card.image_url || '/images/card-back.png'}" 
                            alt="${card.name}"
                            class="w-full h-full object-cover"
                        />
                    </div>
                    <div class="text-center">
                        <h3 class="font-semibold">${card.name}</h3>
                        <p class="text-sm opacity-60">${card.set_name || ''} ${card.card_number ? '#' + card.card_number : ''}</p>
                        ${card.hp ? `<p class="text-sm mt-1"><span class="opacity-60">HP:</span> <span class="font-semibold">${card.hp}</span></p>` : ''}
                    </div>
                </div>
            `;
        }
        
        // Update recent cards display
        window.updateRecentCardsDisplay = function() {
            const recentDiv = document.getElementById('recentCards');
            
            if (recentCards.length === 0) {
                recentDiv.innerHTML = '<p class="text-xs opacity-40">No recent cards</p>';
                return;
            }
            
            recentDiv.innerHTML = recentCards.map((card, index) => `
                <div class="cursor-pointer" onclick="selectCard('${card.id}')" title="${card.name}">
                    <div class="w-12 h-16 rounded overflow-hidden border border-base-300 hover:border-primary transition-colors">
                        <img 
                            src="${card.display_image || card.local_image || card.image_url || '/images/card-back.png'}" 
                            alt="${card.name}"
                            class="w-full h-full object-cover"
                        />
                    </div>
                </div>
            `).join('');
        }
        
        // Show/hide download progress
        window.showDownloadProgress = function(show) {
            const progress = document.getElementById('downloadProgress');
            if (show) {
                progress.classList.remove('hidden');
            } else {
                progress.classList.add('hidden');
            }
        }
        
        // Initialize on page load
        document.addEventListener('DOMContentLoaded', async () => {
            updateSavedDecksList();
            
            // Initialize the Pokemon set resolver in the background
            try {
                await pokemonSetResolver.initialize();
                console.log('Pokemon Set Resolver ready');
            } catch (error) {
                console.warn('Set resolver initialization failed, using fallbacks:', error);
            }
        });
    </script>
</body>
</html>