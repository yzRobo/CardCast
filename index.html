// Render deck cards with images
        async function renderDeckCards(cards, game, category) {
            let cardsHTML = '';
            
            for (let i = 0; i < cards.length; i++) {
                const card = cards[i];
                // Try to find the card image
                let cardImage = '/images/card-back.png';
                let matchedCard = null;
                
                try {
                    // Search by card name only first
                    const response = await fetch(`/api/search/${game}?q=${encodeURIComponent(card.name)}`);
                    const results = await response.json();
                    
                    if (results.length > 0) {
                        // Try to find exact match with set and number if we have that info
                        if (card.setName && card.cardNumber) {
                            // First try exact set name match
                            matchedCard = results.find(r => 
                                r.name.toLowerCase() === card.name.toLowerCase() &&
                                r.set_name && r.set_name.toLowerCase() === card.setName.toLowerCase() &&
                                r.card_number === card.cardNumber
                            );
                            
                            // Try partial set name match
                            if (!matchedCard) {
                                matchedCard = results.find(r => 
                                    r.name.toLowerCase() === card.name.toLowerCase() &&
                                    r.set_name && r.set_name.toLowerCase().includes(card.setName.toLowerCase())
                                );
                            }
                        }
                        
                        // Try to match by set code in the set name
                        if (!matchedCard && card.setCode) {
                            matchedCard = results.find(r => 
                                r.name.toLowerCase() === card.name.toLowerCase() &&
                                r.set_name && (
                                    r.set_name.toLowerCase().includes(card.setName?.toLowerCase() || '') ||
                                    r.set_id === card.setCode.toLowerCase()
                                )
                            );
                        }
                        
                        // Fall back to exact name match
                        if (!matchedCard) {
                            matchedCard = results.find(r => r.name.toLowerCase() === card.name.toLowerCase());
                        }
                        
                        // Last resort - use first result
                        if (!matchedCard && results.length > 0) {
                            matchedCard = results[0];
                        }
                        
                        if (matchedCard) {
                            cardImage = matchedCard.display_image || matchedCard.local_image || matchedCard.image_url || cardImage;
                        }
                    }
                } catch (error) {
                    console.error(`Error fetching card image for ${card.name}:`, error);
                }
                
                // Build card element with better metadata
                const cardTitle = card.setCode ? `${card.name} (${card.setCode} ${card.cardNumber || ''})` : card.name;
                
                if (isEditMode) {
                    cardsHTML += `
                        <div class="deck-card-item edit-mode" 
                             draggable="true"
                             ondragstart="handleCardDragStart(event, '${category}', ${i})"
                             ondragend="handleCardDragEnd(event)"
                             ondragover="event.preventDefault()"
                             data-category="${category}"
                             data-index="${i}"
                             title="${cardTitle}">
                            <div class="deck-card-controls">
                                <button class="deck-card-control-btn" onclick="event.stopPropagation(); adjustCardQuantity('${category}', ${i}, -1)">−</button>
                                <span style="color: white; font-size: 0.875rem;">${card.quantity}</span>
                                <button class="deck-card-control-btn" onclick="event.stopPropagation(); adjustCardQuantity('${category}', ${i}, 1)">+</button>
                                <button class="deck-card-control-btn remove" onclick="event.stopPropagation(); removeCardFromDeck('${category}', ${i})">×</button>
                            </div>
                            <img src="${cardImage}" alt="${cardTitle}" class="deck-card-image" draggable="false" />
                            ${card.quantity > 1 ? `<div class="deck-card-quantity">${card.quantity}</div>` : ''}
                        </div>
                    `;
                } else {
                    cardsHTML += `
                        <div class="deck-card-item" 
                             onclick="selectCardFromDeck('${escape(card.name)}', '${game}')"
                             title="${cardTitle}">
                            <img src="${cardImage}" alt="${cardTitle}" class="deck-card-image" />
                            ${card.quantity > 1 ? `<!DOCTYPE html>
<html lang="en" data-theme="night">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CardCast - TCG Streaming Overlay Tool</title>
    <link rel="stylesheet" href="/css/style.css">
    <style>
        /* Deck View Styles */
        .deck-view-mode {
            background: linear-gradient(135deg, rgba(139, 92, 246, 0.1) 0%, rgba(59, 130, 246, 0.1) 100%);
        }
        
        .deck-section {
            margin-bottom: 2rem;
        }
        
        .deck-section-header {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 1rem;
            padding-bottom: 0.5rem;
            border-bottom: 2px solid rgba(255, 255, 255, 0.1);
        }
        
        .deck-section-title {
            font-size: 1.125rem;
            font-weight: 600;
            color: rgba(255, 255, 255, 0.9);
        }
        
        .deck-section-count {
            background: rgba(139, 92, 246, 0.2);
            color: #a78bfa;
            padding: 0.125rem 0.5rem;
            border-radius: 9999px;
            font-size: 0.875rem;
            font-weight: 500;
        }
        
        .deck-card-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
            gap: 1rem;
            min-height: 150px;
            padding: 0.5rem;
            border-radius: 0.5rem;
            transition: background 0.2s;
        }
        
        .deck-card-grid.drag-over {
            background: rgba(59, 130, 246, 0.1);
            border: 2px dashed rgba(59, 130, 246, 0.5);
        }
        
        .deck-card-item {
            position: relative;
            cursor: pointer;
            transition: transform 0.2s;
        }
        
        .deck-card-item:hover {
            transform: scale(1.05);
            z-index: 10;
        }
        
        .deck-card-item.dragging {
            opacity: 0.5;
            cursor: grabbing;
        }
        
        .deck-card-item.drag-placeholder {
            border: 2px dashed rgba(139, 92, 246, 0.5);
            background: rgba(139, 92, 246, 0.1);
            border-radius: 0.5rem;
        }
        
        .deck-card-item.edit-mode {
            cursor: grab;
        }
        
        .deck-card-item.edit-mode:active {
            cursor: grabbing;
        }
        
        .deck-card-item.edit-mode:hover .deck-card-controls {
            opacity: 1;
        }
        
        .deck-card-quantity {
            position: absolute;
            bottom: -0.25rem;
            right: -0.25rem;
            background: linear-gradient(135deg, #dc2626 0%, #ef4444 100%);
            color: white;
            width: 2rem;
            height: 2rem;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 1.125rem;
            border: 2px solid #1f2937;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
        }
        
        .deck-card-controls {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            background: rgba(0, 0, 0, 0.8);
            border-radius: 0.5rem 0.5rem 0 0;
            padding: 0.25rem;
            display: flex;
            justify-content: space-between;
            opacity: 0;
            transition: opacity 0.2s;
            z-index: 20;
        }
        
        .deck-card-control-btn {
            background: rgba(255, 255, 255, 0.2);
            color: white;
            border: none;
            border-radius: 0.25rem;
            width: 1.5rem;
            height: 1.5rem;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-weight: bold;
            transition: background 0.2s;
        }
        
        .deck-card-control-btn:hover {
            background: rgba(255, 255, 255, 0.3);
        }
        
        .deck-card-control-btn.remove {
            background: rgba(239, 68, 68, 0.5);
        }
        
        .deck-card-control-btn.remove:hover {
            background: rgba(239, 68, 68, 0.7);
        }
        
        .deck-card-image {
            width: 100%;
            height: auto;
            border-radius: 0.5rem;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
        
        .deck-view-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 1rem;
            background: rgba(31, 41, 55, 0.5);
            border-radius: 0.5rem;
            margin-bottom: 1.5rem;
        }
        
        .deck-info {
            display: flex;
            flex-direction: column;
            gap: 0.25rem;
        }
        
        .deck-name {
            font-size: 1.5rem;
            font-weight: bold;
            color: #fff;
        }
        
        .deck-name-input {
            font-size: 1.5rem;
            font-weight: bold;
            background: transparent;
            border: 2px solid transparent;
            color: #fff;
            padding: 0.25rem;
            border-radius: 0.25rem;
            transition: border-color 0.2s;
        }
        
        .deck-name-input:focus {
            outline: none;
            border-color: rgba(139, 92, 246, 0.5);
            background: rgba(0, 0, 0, 0.2);
        }
        
        .deck-stats {
            display: flex;
            gap: 1rem;
            font-size: 0.875rem;
            color: rgba(255, 255, 255, 0.7);
        }
        
        .deck-stat {
            display: flex;
            align-items: center;
            gap: 0.25rem;
        }
        
        .deck-actions {
            display: flex;
            gap: 0.5rem;
        }
        
        .empty-section {
            padding: 2rem;
            text-align: center;
            background: rgba(31, 41, 55, 0.3);
            border-radius: 0.5rem;
            color: rgba(255, 255, 255, 0.5);
        }
        
        .add-card-section {
            margin-top: 2rem;
            padding: 1rem;
            background: rgba(31, 41, 55, 0.3);
            border-radius: 0.5rem;
            display: none;
        }
        
        .add-card-section.show {
            display: block;
        }
        
        .add-card-results {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(80px, 1fr));
            gap: 0.5rem;
            max-height: 200px;
            overflow-y: auto;
            padding: 0.5rem;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 0.5rem;
            margin-top: 0.5rem;
        }
        
        .add-card-result {
            cursor: pointer;
            transition: transform 0.2s;
            border-radius: 0.25rem;
            overflow: hidden;
        }
        
        .add-card-result:hover {
            transform: scale(1.1);
            z-index: 10;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
        }
        
        .add-card-result img {
            width: 100%;
            height: auto;
            display: block;
        }
        
        .edit-mode-indicator {
            background: linear-gradient(135deg, #f59e0b 0%, #f97316 100%);
            color: white;
            padding: 0.5rem 1rem;
            border-radius: 0.5rem;
            margin-bottom: 1rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
    </style>
</head>
<body class="min-h-screen bg-base-100">
    <!-- Header -->
    <div class="navbar bg-base-200 border-b border-base-300 fixed top-0 z-50">
        <div class="navbar-start">
            <div class="text-xl font-bold">
                <span class="text-primary">Card</span><span>Cast</span>
            </div>
            <div class="badge badge-primary badge-sm ml-2">v1.0.0</div>
        </div>
        <div class="navbar-end">
            <div id="obsStatus" class="badge badge-error gap-2">
                <div class="w-2 h-2 rounded-full bg-current status-indicator"></div>
                <span class="status-text">OBS Not Connected</span>
            </div>
        </div>
    </div>

    <!-- Main Container -->
    <div class="max-w-full px-4 pt-20 pb-8">
        <div class="grid grid-cols-1 lg:grid-cols-12 gap-4">
            
            <!-- Left Sidebar - Games Panel -->
            <aside class="col-span-12 lg:col-span-3 xl:col-span-2">
                <div class="card bg-base-200">
                    <div class="card-body p-4">
                        <h2 class="text-sm font-semibold opacity-60 uppercase tracking-wider">Select Game</h2>
                        
                        <div class="space-y-2" id="gamesList">
                            <!-- Games will be populated here by JavaScript -->
                        </div>
                        
                        <div class="divider my-3"></div>
                        
                        <h3 class="text-sm font-semibold opacity-60 uppercase tracking-wider">Download Options</h3>
                        <div class="form-control space-y-1">
                            <label class="label cursor-pointer justify-start gap-3 py-1">
                                <input type="radio" name="sets" value="1" class="radio radio-primary radio-sm" checked />
                                <span class="label-text text-sm">Most recent set only</span>
                            </label>
                            <label class="label cursor-pointer justify-start gap-3 py-1">
                                <input type="radio" name="sets" value="3" class="radio radio-primary radio-sm" />
                                <span class="label-text text-sm">Last 3 sets</span>
                            </label>
                            <label class="label cursor-pointer justify-start gap-3 py-1">
                                <input type="radio" name="sets" value="5" class="radio radio-primary radio-sm" />
                                <span class="label-text text-sm">Last 5 sets</span>
                            </label>
                            <label class="label cursor-pointer justify-start gap-3 py-1">
                                <input type="radio" name="sets" value="10" class="radio radio-primary radio-sm" />
                                <span class="label-text text-sm">Last 10 sets</span>
                            </label>
                            <label class="label cursor-pointer justify-start gap-3 py-1">
                                <input type="radio" name="sets" value="all" class="radio radio-primary radio-sm" />
                                <span class="label-text text-sm">All available sets</span>
                            </label>
                        </div>
                    </div>
                </div>
            </aside>

            <!-- Center - Search Section -->
            <main class="col-span-12 lg:col-span-6 xl:col-span-7">
                <!-- Search Bar -->
                <div class="card bg-base-200 mb-4">
                    <div class="card-body p-4">
                        <div class="join w-full">
                            <input 
                                type="text" 
                                id="searchInput"
                                placeholder="Select a game and download data to search..." 
                                class="input input-bordered join-item flex-1"
                                disabled
                            />
                            <button class="btn btn-square join-item" id="searchButton">
                                <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z" />
                                </svg>
                            </button>
                        </div>
                        <!-- Toggle for deck view mode -->
                        <div id="deckViewToggle" class="hidden mt-2">
                            <button class="btn btn-sm btn-ghost" onclick="exitDeckView()">
                                ← Back to Search
                            </button>
                        </div>
                    </div>
                </div>
                
                <!-- Search Results / Deck View -->
                <div class="card bg-base-200 min-h-[700px]" id="mainContentCard">
                    <div class="card-body p-4">
                        <div id="searchResults">
                            <div class="flex flex-col items-center justify-center py-20">
                                <div class="text-6xl mb-4">📦</div>
                                <p class="text-base-content/60">Select a game and download card data to begin</p>
                            </div>
                        </div>
                        
                        <!-- Deck View (hidden by default) -->
                        <div id="deckView" class="hidden">
                            <!-- Deck content will be populated here -->
                        </div>
                    </div>
                </div>
            </main>

            <!-- Right Sidebar - Deck Management -->
            <aside class="col-span-12 lg:col-span-3 space-y-4">
                <!-- Match Control Links -->
                <div class="card bg-base-200">
                    <div class="card-body p-4">
                        <h2 class="text-sm font-semibold opacity-60 uppercase tracking-wider">Match Controls</h2>
                        
                        <div class="space-y-2 mt-3">
                            <button onclick="window.open('/pokemon-match-control', '_blank')" class="btn btn-sm btn-primary w-full" id="pokemonMatchBtn" style="display: none;">
                                ⚡ Pokemon Match Control
                            </button>
                            
                            <p class="text-xs text-center opacity-40" id="noGameSelected">
                                Select a game to access match controls
                            </p>
                        </div>
                    </div>
                </div>
                
                <!-- Saved Decks -->
                <div class="card bg-base-200">
                    <div class="card-body p-4">
                        <h2 class="text-sm font-semibold opacity-60 uppercase tracking-wider">Saved Decks</h2>
                        
                        <div id="savedDecksList" class="space-y-2 mt-3">
                            <p class="text-xs text-center opacity-40">No decks saved yet</p>
                        </div>
                        
                        <button class="btn btn-sm btn-outline w-full mt-3" onclick="exportAllDecks()">
                            Export All Decks
                        </button>
                    </div>
                </div>

                <!-- Deck Import -->
                <div class="card bg-base-200">
                    <div class="card-body p-4">
                        <h2 class="text-sm font-semibold opacity-60 uppercase tracking-wider">Import Deck</h2>
                        
                        <input 
                            type="text"
                            id="deckNameInput"
                            class="input input-bordered input-sm w-full mt-2"
                            placeholder="Deck Name (e.g., Gardevoir ex)"
                        />
                        
                        <select id="deckGameSelect" class="select select-bordered select-sm w-full mt-2">
                            <option value="">Select game for this deck</option>
                            <option value="pokemon">Pokemon</option>
                            <option value="magic">Magic: The Gathering</option>
                            <option value="yugioh">Yu-Gi-Oh!</option>
                            <option value="lorcana">Disney Lorcana</option>
                            <option value="onepiece">One Piece</option>
                        </select>
                        
                        <textarea 
                            id="deckImportText"
                            class="textarea textarea-bordered textarea-sm w-full mt-2"
                            rows="6"
                            placeholder="Paste deck list here (Limitless TCG, PTCGL, or simple card names)..."
                        ></textarea>
                        
                        <div class="join w-full mt-2">
                            <button class="btn btn-sm btn-primary join-item flex-1" onclick="importAndSaveDeck()">Import & Save</button>
                            <button class="btn btn-sm join-item flex-1" onclick="clearDeckImport()">Clear</button>
                        </div>
                        
                        <div class="divider my-2"></div>
                        
                        <p class="text-xs font-semibold opacity-60 uppercase tracking-wider">Quick Search Deck</p>
                        <div class="form-control mt-2">
                            <label class="label cursor-pointer">
                                <span class="label-text text-sm">Search imported cards only</span>
                                <input type="checkbox" id="searchDeckOnly" class="checkbox checkbox-primary checkbox-sm" />
                            </label>
                        </div>
                    </div>
                </div>

                <!-- OBS Links -->
                <div class="card bg-base-200">
                    <div class="card-body p-4">
                        <h2 class="text-sm font-semibold opacity-60 uppercase tracking-wider">OBS Browser Sources</h2>
                        
                        <div class="space-y-2 mt-3">
                            <div class="bg-base-300 p-2 rounded-lg">
                                <div class="flex justify-between items-center">
                                    <div class="min-w-0">
                                        <p class="text-xs opacity-60">Main Overlay</p>
                                        <p class="text-xs font-mono truncate" id="obsMainUrl">http://localhost:3888/overlay</p>
                                    </div>
                                    <button class="btn btn-ghost btn-xs copy-btn" data-copy="obsMainUrl">Copy</button>
                                </div>
                            </div>
                            
                            <div class="bg-base-300 p-2 rounded-lg">
                                <div class="flex justify-between items-center">
                                    <div class="min-w-0">
                                        <p class="text-xs opacity-60">Pokemon Match</p>
                                        <p class="text-xs font-mono truncate" id="obsPokemonUrl">http://localhost:3888/pokemon-match</p>
                                    </div>
                                    <button class="btn btn-ghost btn-xs copy-btn" data-copy="obsPokemonUrl">Copy</button>
                                </div>
                            </div>
                            
                            <div class="bg-base-300 p-2 rounded-lg">
                                <div class="flex justify-between items-center">
                                    <div class="min-w-0">
                                        <p class="text-xs opacity-60">Prize Cards</p>
                                        <p class="text-xs font-mono truncate" id="obsPrizesUrl">http://localhost:3888/prizes</p>
                                    </div>
                                    <button class="btn btn-ghost btn-xs copy-btn" data-copy="obsPrizesUrl">Copy</button>
                                </div>
                            </div>
                            
                            <div class="bg-base-300 p-2 rounded-lg">
                                <div class="flex justify-between items-center">
                                    <div class="flex justify-between items-center w-full">
                                        <div class="min-w-0">
                                            <p class="text-xs opacity-60">Deck List</p>
                                            <p class="text-xs font-mono truncate" id="obsDecklistUrl">http://localhost:3888/decklist</p>
                                        </div>
                                        <button class="btn btn-ghost btn-xs copy-btn" data-copy="obsDecklistUrl">Copy</button>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Recent Cards -->
                <div class="card bg-base-200">
                    <div class="card-body p-4">
                        <h2 class="text-sm font-semibold opacity-60 uppercase tracking-wider">Recent Cards</h2>
                        <div class="flex gap-2 flex-wrap mt-2" id="recentCards">
                            <!-- Recent cards will appear here -->
                        </div>
                    </div>
                </div>
            </aside>
        </div>
    </div>

    <!-- Download Progress Toast -->
    <div class="toast toast-end">
        <div class="alert alert-info hidden" id="downloadProgress">
            <span class="loading loading-spinner"></span>
            <div>
                <div class="text-sm font-semibold">Downloading...</div>
                <div class="text-xs" id="progressText">0%</div>
                <progress class="progress progress-primary w-32" id="progressFill" value="0" max="100"></progress>
            </div>
        </div>
    </div>

    <!-- Socket.io -->
    <script src="/socket.io/socket.io.js"></script>
    <!-- Main JavaScript -->
    <script src="/js/main.js"></script>
    
    <script>
        // Deck management system
        let savedDecks = JSON.parse(localStorage.getItem('savedDecks')) || {};
        let currentImportedDeck = null;
        let isDeckViewMode = false;
        let currentViewedDeck = null;
        let isEditMode = false;
        let editingDeck = null;
        let draggedCard = null;
        let draggedFromCategory = null;
        let draggedFromIndex = null;
        
        // Enhanced deck parsing function - keep original card info
        window.parseDeckList = function(text) {
            const lines = text.split('\n').filter(line => line.trim());
            const deck = {
                pokemon: [],
                trainers: [],
                energy: []
            };
            
            let currentSection = null;
            
            for (const line of lines) {
                const trimmed = line.trim();
                
                // Check for section headers
                if (trimmed.toLowerCase().includes('pokémon') || trimmed.toLowerCase().includes('pokemon')) {
                    currentSection = 'pokemon';
                    continue;
                } else if (trimmed.toLowerCase().includes('trainer')) {
                    currentSection = 'trainers';
                    continue;
                } else if (trimmed.toLowerCase().includes('energy')) {
                    currentSection = 'energy';
                    continue;
                }
                
                // Parse card lines - capture everything
                const match = trimmed.match(/^(\d+)\s+(.+?)(?:\s+([A-Z0-9]{2,5})\s+(\d+[a-zA-Z]?))?$/);
                if (match && currentSection) {
                    const [_, quantity, cardName, setCode, cardNumber] = match;
                    
                    // Store the card information
                    const cardData = {
                        name: cardName.trim(),
                        quantity: parseInt(quantity),
                        setCode: setCode || null,
                        cardNumber: cardNumber || null,
                        originalLine: trimmed // Keep the original line for reference
                    };
                    
                    deck[currentSection].push(cardData);
                }
            }
            
            return deck;
        };
        
        // Render deck cards with images
        async function renderDeckCards(cards, game, category) {
            let cardsHTML = '';
            
            for (let i = 0; i < cards.length; i++) {
                const card = cards[i];
                // Try to find the card image
                let cardImage = '/images/card-back.png';
                let matchedCard = null;
                
                try {
                    // Search by card name only
                    const response = await fetch(`/api/search/${game}?q=${encodeURIComponent(card.name)}`);
                    const results = await response.json();
                    
                    if (results.length > 0) {
                        // If we have set and number info, try to find the best match
                        if (card.cardNumber) {
                            // Try to match by card number (often unique within results)
                            matchedCard = results.find(r => 
                                r.name.toLowerCase() === card.name.toLowerCase() &&
                                r.card_number && r.card_number.toString() === card.cardNumber.toString()
                            );
                        }
                        
                        // If no match by number, try exact name match
                        if (!matchedCard) {
                            matchedCard = results.find(r => r.name.toLowerCase() === card.name.toLowerCase());
                        }
                        
                        // Use first result as fallback
                        if (!matchedCard && results.length > 0) {
                            matchedCard = results[0];
                        }
                        
                        if (matchedCard) {
                            cardImage = matchedCard.display_image || matchedCard.local_image || matchedCard.image_url || cardImage;
                            // Store the matched card data for future reference
                            card.matchedId = matchedCard.id;
                        }
                    }
                } catch (error) {
                    console.error(`Error fetching card image for ${card.name}:`, error);
                }
                
                // Build card element with original info
                const cardTitle = card.originalLine || card.name;
                
                if (isEditMode) {
                    cardsHTML += `
                        <div class="deck-card-item edit-mode" 
                             draggable="true"
                             ondragstart="handleCardDragStart(event, '${category}', ${i})"
                             ondragend="handleCardDragEnd(event)"
                             ondragover="event.preventDefault()"
                             data-category="${category}"
                             data-index="${i}"
                             title="${cardTitle}">
                            <div class="deck-card-controls">
                                <button class="deck-card-control-btn" onclick="event.stopPropagation(); adjustCardQuantity('${category}', ${i}, -1)">−</button>
                                <span style="color: white; font-size: 0.875rem;">${card.quantity}</span>
                                <button class="deck-card-control-btn" onclick="event.stopPropagation(); adjustCardQuantity('${category}', ${i}, 1)">+</button>
                                <button class="deck-card-control-btn remove" onclick="event.stopPropagation(); removeCardFromDeck('${category}', ${i})">×</button>
                            </div>
                            <img src="${cardImage}" alt="${cardTitle}" class="deck-card-image" draggable="false" />
                            ${card.quantity > 1 ? `<div class="deck-card-quantity">${card.quantity}</div>` : ''}
                        </div>
                    `;
                } else {
                    cardsHTML += `
                        <div class="deck-card-item" 
                             onclick="selectCardFromDeck('${escape(card.name)}', '${game}', '${card.matchedId || ''}')"
                             title="${cardTitle}">
                            <img src="${cardImage}" alt="${cardTitle}" class="deck-card-image" />
                            ${card.quantity > 1 ? `<div class="deck-card-quantity">${card.quantity}</div>` : ''}
                        </div>
                    `;
                }
            }
            
            return cardsHTML;
        }
        
        // Select card from deck view - updated to use matched ID if available
        window.selectCardFromDeck = async function(cardName, game, matchedId) {
            // Unescape the card name
            cardName = cardName.replace(/\\'/g, "'").replace(/\\"/g, '"');
            
            try {
                // If we have a matched ID, try to fetch that specific card
                if (matchedId && matchedId !== '') {
                    try {
                        const response = await fetch(`/api/card/${game}/${matchedId}`);
                        if (response.ok) {
                            const card = await response.json();
                            if (window.selectCard) {
                                window.selectCard(card.id);
                                return;
                            }
                        }
                    } catch (err) {
                        console.log('Could not fetch by ID, falling back to search');
                    }
                }
                
                // Fall back to searching by name
                const response = await fetch(`/api/search/${game}?q=${encodeURIComponent(cardName)}`);
                const results = await response.json();
                
                if (results.length > 0) {
                    const exactMatch = results.find(r => r.name.toLowerCase() === cardName.toLowerCase());
                    const card = exactMatch || results[0];
                    
                    // Call the regular selectCard function
                    if (window.selectCard) {
                        window.selectCard(card.id);
                    }
                }
            } catch (error) {
                console.error('Error selecting card from deck:', error);
            }
        }
        
        // Update OBS status display
        window.updateOBSStatus = function(connected) {
            isOBSConnected = connected;
            const statusElement = document.getElementById('obsStatus');
            const statusText = statusElement.querySelector('.status-text');
            
            if (connected) {
                statusElement.classList.remove('badge-error');
                statusElement.classList.add('badge-success');
                statusText.textContent = 'OBS Connected';
            } else {
                statusElement.classList.remove('badge-success');
                statusElement.classList.add('badge-error');
                statusText.textContent = 'OBS Not Connected';
            }
        }
        
        // Override selectGame to show appropriate match control button
        const originalSelectGame = window.selectGame;
        window.selectGame = function(gameId, hasData) {
            // Call original function
            if (originalSelectGame) {
                originalSelectGame(gameId, hasData);
            }
            
            // Show/hide match control buttons based on game
            document.getElementById('pokemonMatchBtn').style.display = gameId === 'pokemon' ? 'block' : 'none';
            document.getElementById('noGameSelected').style.display = gameId ? 'none' : 'block';
            
            // Update deck game selector
            document.getElementById('deckGameSelect').value = gameId;
            
            // Update current game
            currentGame = gameId;
            
            // Exit deck view if in it
            if (isDeckViewMode) {
                exitDeckView();
            }
            
            // Update search based on deck filter
            if (document.getElementById('searchDeckOnly').checked && currentImportedDeck) {
                // Filter search to only deck cards
                updateSearchToDeckOnly();
            }
        }
        
        // Display deck view
        window.displayDeckView = async function(deck, game) {
            isDeckViewMode = true;
            currentViewedDeck = deck;
            editingDeck = JSON.parse(JSON.stringify(deck)); // Deep copy for editing
            
            // Update UI state
            document.getElementById('searchResults').classList.add('hidden');
            document.getElementById('deckView').classList.remove('hidden');
            document.getElementById('deckViewToggle').classList.remove('hidden');
            document.getElementById('mainContentCard').classList.add('deck-view-mode');
            document.getElementById('searchInput').disabled = true;
            
            // Render the deck
            await renderDeckView();
        }
        
        // Render deck view
        window.renderDeckView = async function() {
            const deck = editingDeck || currentViewedDeck;
            const game = deck.game;
            
            // Calculate totals
            const pokemonCount = deck.pokemon?.reduce((sum, c) => sum + c.quantity, 0) || 0;
            const trainerCount = deck.trainers?.reduce((sum, c) => sum + c.quantity, 0) || 0;
            const energyCount = deck.energy?.reduce((sum, c) => sum + c.quantity, 0) || 0;
            const totalCards = pokemonCount + trainerCount + energyCount;
            
            // Build deck view HTML
            let deckHTML = `
                <div class="deck-view-header">
                    <div class="deck-info">
                        ${isEditMode ? 
                            `<input type="text" class="deck-name-input" id="deckNameEdit" value="${deck.name}" />` :
                            `<div class="deck-name">${deck.name}</div>`
                        }
                        <div class="deck-stats">
                            <div class="deck-stat">
                                <span>📦</span>
                                <span>${totalCards} cards</span>
                            </div>
                            <div class="deck-stat">
                                <span>🎮</span>
                                <span>${game.charAt(0).toUpperCase() + game.slice(1)}</span>
                            </div>
                        </div>
                    </div>
                    <div class="deck-actions">
                        ${isEditMode ? `
                            <button class="btn btn-sm btn-success" onclick="saveDeckEdits()">Save Changes</button>
                            <button class="btn btn-sm btn-warning" onclick="cancelDeckEdit()">Cancel</button>
                        ` : `
                            <button class="btn btn-sm btn-primary" onclick="sendDeckToOverlay()">Send to Overlay</button>
                            <button class="btn btn-sm btn-secondary" onclick="enterEditMode()">Edit Deck</button>
                            <button class="btn btn-sm btn-ghost" onclick="exitDeckView()">Close</button>
                        `}
                    </div>
                </div>
            `;
            
            // Add edit mode indicator
            if (isEditMode) {
                deckHTML += `
                    <div class="edit-mode-indicator">
                        <span>✏️</span>
                        <span>Edit Mode - Drag cards to reorder or move between sections</span>
                    </div>
                `;
            }
            
            // Add Pokemon section
            const pokemonCards = deck.pokemon || [];
            deckHTML += `
                <div class="deck-section">
                    <div class="deck-section-header">
                        <span class="deck-section-title">Pokémon</span>
                        <span class="deck-section-count">${pokemonCount}</span>
                    </div>
                    <div class="deck-card-grid" id="pokemon-grid" 
                         ${isEditMode ? 'ondragover="handleDragOver(event)" ondragleave="handleDragLeave(event)" ondrop="handleDrop(event, \'pokemon\')"' : ''}>
                        ${pokemonCards.length > 0 ? await renderDeckCards(pokemonCards, game, 'pokemon') : 
                          (isEditMode ? '<div class="empty-section">Drop Pokémon cards here</div>' : '')}
                    </div>
                </div>
            `;
            
            // Add Trainers section
            const trainerCards = deck.trainers || [];
            deckHTML += `
                <div class="deck-section">
                    <div class="deck-section-header">
                        <span class="deck-section-title">Trainers</span>
                        <span class="deck-section-count">${trainerCount}</span>
                    </div>
                    <div class="deck-card-grid" id="trainers-grid"
                         ${isEditMode ? 'ondragover="handleDragOver(event)" ondragleave="handleDragLeave(event)" ondrop="handleDrop(event, \'trainers\')"' : ''}>
                        ${trainerCards.length > 0 ? await renderDeckCards(trainerCards, game, 'trainers') : 
                          (isEditMode ? '<div class="empty-section">Drop Trainer cards here</div>' : '')}
                    </div>
                </div>
            `;
            
            // Add Energy section
            const energyCards = deck.energy || [];
            deckHTML += `
                <div class="deck-section">
                    <div class="deck-section-header">
                        <span class="deck-section-title">Energy</span>
                        <span class="deck-section-count">${energyCount}</span>
                    </div>
                    <div class="deck-card-grid" id="energy-grid"
                         ${isEditMode ? 'ondragover="handleDragOver(event)" ondragleave="handleDragLeave(event)" ondrop="handleDrop(event, \'energy\')"' : ''}>
                        ${energyCards.length > 0 ? await renderDeckCards(energyCards, game, 'energy') : 
                          (isEditMode ? '<div class="empty-section">Drop Energy cards here</div>' : '')}
                    </div>
                </div>
            `;
            
            // Add card search section if in edit mode
            if (isEditMode) {
                deckHTML += `
                    <div class="add-card-section show">
                        <h3 class="text-lg font-semibold mb-3">Add Cards</h3>
                        <div class="flex gap-2 mb-3">
                            <input type="text" 
                                   id="addCardSearch" 
                                   class="input input-bordered flex-1" 
                                   placeholder="Search for cards to add..."
                                   onkeyup="searchCardsToAdd(event)">
                            <select id="addCardCategory" class="select select-bordered">
                                <option value="pokemon">Pokémon</option>
                                <option value="trainers">Trainers</option>
                                <option value="energy">Energy</option>
                            </select>
                        </div>
                        <div id="addCardResults" class="add-card-results">
                            <!-- Search results will appear here -->
                        </div>
                    </div>
                `;
            }
            
            document.getElementById('deckView').innerHTML = deckHTML;
        }
        
        // Render deck cards with images
        async function renderDeckCards(cards, game, category) {
            let cardsHTML = '';
            
            for (let i = 0; i < cards.length; i++) {
                const card = cards[i];
                // Try to find the card image
                let cardImage = '/images/card-back.png';
                let matchedCard = null;
                
                try {
                    // First try to search with set information if available
                    let searchQuery = card.name;
                    if (card.setName) {
                        searchQuery = `${card.name} ${card.setName}`;
                    }
                    
                    const response = await fetch(`/api/search/${game}?q=${encodeURIComponent(searchQuery)}`);
                    const results = await response.json();
                    
                    if (results.length > 0) {
                        // Try to find exact match with set and number
                        if (card.setName && card.cardNumber) {
                            matchedCard = results.find(r => 
                                r.name.toLowerCase() === card.name.toLowerCase() &&
                                r.set_name && r.set_name.toLowerCase().includes(card.setName.toLowerCase()) &&
                                r.card_number === card.cardNumber
                            );
                        }
                        
                        // If no exact match, try just name and set
                        if (!matchedCard && card.setName) {
                            matchedCard = results.find(r => 
                                r.name.toLowerCase() === card.name.toLowerCase() &&
                                r.set_name && r.set_name.toLowerCase().includes(card.setName.toLowerCase())
                            );
                        }
                        
                        // Fall back to exact name match
                        if (!matchedCard) {
                            matchedCard = results.find(r => r.name.toLowerCase() === card.name.toLowerCase());
                        }
                        
                        // Last resort - use first result
                        if (!matchedCard) {
                            matchedCard = results[0];
                        }
                        
                        if (matchedCard) {
                            cardImage = matchedCard.display_image || matchedCard.local_image || matchedCard.image_url || cardImage;
                        }
                    }
                } catch (error) {
                    console.error(`Error fetching card image for ${card.name}:`, error);
                }
                
                // Build card element with better metadata
                const cardTitle = card.setCode ? `${card.name} (${card.setCode} ${card.cardNumber || ''})` : card.name;
                
                if (isEditMode) {
                    cardsHTML += `
                        <div class="deck-card-item edit-mode" 
                             draggable="true"
                             ondragstart="handleCardDragStart(event, '${category}', ${i})"
                             ondragend="handleCardDragEnd(event)"
                             ondragover="event.preventDefault()"
                             data-category="${category}"
                             data-index="${i}"
                             title="${cardTitle}">
                            <div class="deck-card-controls">
                                <button class="deck-card-control-btn" onclick="event.stopPropagation(); adjustCardQuantity('${category}', ${i}, -1)">−</button>
                                <span style="color: white; font-size: 0.875rem;">${card.quantity}</span>
                                <button class="deck-card-control-btn" onclick="event.stopPropagation(); adjustCardQuantity('${category}', ${i}, 1)">+</button>
                                <button class="deck-card-control-btn remove" onclick="event.stopPropagation(); removeCardFromDeck('${category}', ${i})">×</button>
                            </div>
                            <img src="${cardImage}" alt="${cardTitle}" class="deck-card-image" draggable="false" />
                            ${card.quantity > 1 ? `<div class="deck-card-quantity">${card.quantity}</div>` : ''}
                        </div>
                    `;
                } else {
                    cardsHTML += `
                        <div class="deck-card-item" 
                             onclick="selectCardFromDeck('${escape(card.name)}', '${game}')"
                             title="${cardTitle}">
                            <img src="${cardImage}" alt="${cardTitle}" class="deck-card-image" />
                            ${card.quantity > 1 ? `<div class="deck-card-quantity">${card.quantity}</div>` : ''}
                        </div>
                    `;
                }
            }
            
            return cardsHTML;
        }
        
        // Handle card drag start
        window.handleCardDragStart = function(event, category, index) {
            if (!editingDeck || !editingDeck[category] || !editingDeck[category][index]) {
                console.error('Invalid drag start:', category, index);
                return;
            }
            
            draggedCard = editingDeck[category][index];
            draggedFromCategory = category;
            draggedFromIndex = index;
            event.target.classList.add('dragging');
            event.dataTransfer.effectAllowed = 'move';
            event.dataTransfer.setData('text/plain', ''); // Required for Firefox
            
            console.log('Dragging card:', draggedCard.name, 'from', category, 'index', index);
        }
        
        // Handle card drag end
        window.handleCardDragEnd = function(event) {
            event.target.classList.remove('dragging');
            
            // Remove all drag-over classes
            document.querySelectorAll('.drag-over').forEach(el => {
                el.classList.remove('drag-over');
            });
        }
        
        // Handle drag over
        window.handleDragOver = function(event) {
            event.preventDefault();
            event.dataTransfer.dropEffect = 'move';
            
            const grid = event.currentTarget;
            grid.classList.add('drag-over');
        }
        
        // Handle drag leave
        window.handleDragLeave = function(event) {
            event.currentTarget.classList.remove('drag-over');
        }
        
        // Handle drop
        window.handleDrop = function(event, targetCategory) {
            event.preventDefault();
            event.currentTarget.classList.remove('drag-over');
            
            if (!draggedCard || !draggedFromCategory || draggedFromIndex === null) return;
            
            // Initialize category arrays if they don't exist
            if (!editingDeck[targetCategory]) {
                editingDeck[targetCategory] = [];
            }
            if (!editingDeck[draggedFromCategory]) {
                editingDeck[draggedFromCategory] = [];
            }
            
            // Find the target position
            const targetElement = event.target.closest('.deck-card-item');
            let targetIndex = editingDeck[targetCategory].length; // Default to end
            
            if (targetElement && targetElement.dataset.category === targetCategory) {
                targetIndex = parseInt(targetElement.dataset.index) || 0;
                
                // Determine if we're dropping before or after
                const rect = targetElement.getBoundingClientRect();
                const midpoint = rect.left + rect.width / 2;
                if (event.clientX > midpoint) {
                    targetIndex++;
                }
            }
            
            // If moving within same category
            if (draggedFromCategory === targetCategory) {
                // Remove from original position
                const [removed] = editingDeck[draggedFromCategory].splice(draggedFromIndex, 1);
                
                // Adjust target index if necessary
                if (targetIndex > draggedFromIndex) {
                    targetIndex--;
                }
                
                // Insert at new position
                editingDeck[targetCategory].splice(targetIndex, 0, removed);
            } else {
                // Moving to different category
                // Remove from original category
                const [removed] = editingDeck[draggedFromCategory].splice(draggedFromIndex, 1);
                
                // Add to new category
                editingDeck[targetCategory].splice(targetIndex, 0, removed);
            }
            
            // Reset drag state
            draggedCard = null;
            draggedFromCategory = null;
            draggedFromIndex = null;
            
            // Re-render
            renderDeckView();
        }
        
        // Enter edit mode
        window.enterEditMode = function() {
            isEditMode = true;
            editingDeck = JSON.parse(JSON.stringify(currentViewedDeck)); // Deep copy
            renderDeckView();
        }
        
        // Cancel deck edit
        window.cancelDeckEdit = function() {
            isEditMode = false;
            editingDeck = null;
            renderDeckView();
        }
        
        // Save deck edits
        window.saveDeckEdits = function() {
            const newName = document.getElementById('deckNameEdit').value.trim();
            if (!newName) {
                alert('Deck name cannot be empty');
                return;
            }
            
            // Update deck name
            editingDeck.name = newName;
            
            // Find and update the deck in savedDecks
            const game = editingDeck.game;
            const oldName = currentViewedDeck.name;
            
            if (savedDecks[game]) {
                const deckIndex = savedDecks[game].findIndex(d => d.name === oldName);
                if (deckIndex > -1) {
                    savedDecks[game][deckIndex] = editingDeck;
                    localStorage.setItem('savedDecks', JSON.stringify(savedDecks));
                    
                    // Update current viewed deck
                    currentViewedDeck = JSON.parse(JSON.stringify(editingDeck));
                    currentImportedDeck = currentViewedDeck;
                    
                    // Exit edit mode
                    isEditMode = false;
                    editingDeck = null;
                    
                    // Update UI
                    updateSavedDecksList();
                    renderDeckView();
                    
                    alert('Deck saved successfully!');
                }
            }
        }
        
        // Adjust card quantity
        window.adjustCardQuantity = function(category, index, delta) {
            const card = editingDeck[category][index];
            card.quantity = Math.max(1, Math.min(4, card.quantity + delta)); // Min 1, Max 4
            renderDeckView();
        }
        
        // Remove card from deck
        window.removeCardFromDeck = function(category, index) {
            editingDeck[category].splice(index, 1);
            renderDeckView();
        }
        
        // Search cards to add
        window.searchCardsToAdd = async function(event) {
            const query = event.target.value.trim();
            if (query.length < 2) {
                document.getElementById('addCardResults').innerHTML = '';
                return;
            }
            
            const game = editingDeck.game;
            
            try {
                const response = await fetch(`/api/search/${game}?q=${encodeURIComponent(query)}`);
                const results = await response.json();
                
                const resultsHTML = results.slice(0, 24).map(card => `
                    <div class="add-card-result" 
                         onclick="addCardToDeck('${escape(card.name)}', '${card.display_image || card.local_image || card.image_url || '/images/card-back.png'}')">
                        <img src="${card.display_image || card.local_image || card.image_url || '/images/card-back.png'}" 
                             alt="${card.name}"
                             title="${card.name}">
                    </div>
                `).join('');
                
                document.getElementById('addCardResults').innerHTML = resultsHTML || '<p class="col-span-full text-center opacity-50">No cards found</p>';
            } catch (error) {
                console.error('Error searching cards:', error);
            }
        }
        
        // Add card to deck
        window.addCardToDeck = function(cardName, cardImage) {
            // Unescape the card name
            cardName = cardName.replace(/\\'/g, "'").replace(/\\"/g, '"');
            
            const category = document.getElementById('addCardCategory').value;
            
            // Initialize category if it doesn't exist
            if (!editingDeck[category]) {
                editingDeck[category] = [];
            }
            
            // Check if card already exists in the category
            const existingCard = editingDeck[category].find(c => c.name === cardName);
            
            if (existingCard) {
                // Increase quantity (max 4)
                if (existingCard.quantity < 4) {
                    existingCard.quantity++;
                } else {
                    alert('Maximum 4 copies of a card allowed');
                    return;
                }
            } else {
                // Add new card
                editingDeck[category].push({
                    name: cardName,
                    quantity: 1
                });
            }
            
            // Clear search
            document.getElementById('addCardSearch').value = '';
            document.getElementById('addCardResults').innerHTML = '';
            
            // Re-render deck
            renderDeckView();
        }
        
        // Select card from deck view
        window.selectCardFromDeck = async function(cardName, game) {
            try {
                const response = await fetch(`/api/search/${game}?q=${encodeURIComponent(cardName)}`);
                const results = await response.json();
                
                if (results.length > 0) {
                    const exactMatch = results.find(r => r.name.toLowerCase() === cardName.toLowerCase());
                    const card = exactMatch || results[0];
                    
                    // Call the regular selectCard function
                    if (window.selectCard) {
                        window.selectCard(card.id);
                    }
                }
            } catch (error) {
                console.error('Error selecting card from deck:', error);
            }
        }
        
        // Exit deck view mode
        window.exitDeckView = function() {
            isDeckViewMode = false;
            currentViewedDeck = null;
            
            // Reset UI state
            document.getElementById('searchResults').classList.remove('hidden');
            document.getElementById('deckView').classList.add('hidden');
            document.getElementById('deckViewToggle').classList.add('hidden');
            document.getElementById('mainContentCard').classList.remove('deck-view-mode');
            
            // Re-enable search if game is selected
            if (currentGame) {
                document.getElementById('searchInput').disabled = false;
            }
            
            // Clear deck view content
            document.getElementById('deckView').innerHTML = '';
        }
        
        // Send deck to overlay
        window.sendDeckToOverlay = function() {
            if (!currentViewedDeck) return;
            
            // Send deck to decklist overlay
            if (window.socket) {
                window.socket.emit('decklist-update', {
                    deck: currentViewedDeck,
                    show: true
                });
                
                alert('Deck sent to overlay!');
            }
        }
        
        // Import and save deck
        window.importAndSaveDeck = function() {
            const deckName = document.getElementById('deckNameInput').value.trim();
            const deckGame = document.getElementById('deckGameSelect').value;
            const deckText = document.getElementById('deckImportText').value.trim();
            
            if (!deckName) {
                alert('Please enter a deck name');
                return;
            }
            
            if (!deckGame) {
                alert('Please select a game for this deck');
                return;
            }
            
            if (!deckText) {
                alert('Please paste a deck list');
                return;
            }
            
            // Parse the deck
            const deck = parseDeckList(deckText);
            deck.name = deckName;
            deck.game = deckGame;
            deck.dateAdded = new Date().toISOString();
            
            // Save to localStorage
            if (!savedDecks[deckGame]) {
                savedDecks[deckGame] = [];
            }
            
            // Check if deck with same name exists
            const existingIndex = savedDecks[deckGame].findIndex(d => d.name === deckName);
            if (existingIndex > -1) {
                if (!confirm(`Deck "${deckName}" already exists. Replace it?`)) {
                    return;
                }
                savedDecks[deckGame][existingIndex] = deck;
            } else {
                savedDecks[deckGame].push(deck);
            }
            
            localStorage.setItem('savedDecks', JSON.stringify(savedDecks));
            
            // Set as current imported deck
            currentImportedDeck = deck;
            
            // Update UI
            updateSavedDecksList();
            clearDeckImport();
            
            alert(`Deck "${deckName}" saved successfully!`);
        }
        
        // Update saved decks list
        window.updateSavedDecksList = function() {
            const listDiv = document.getElementById('savedDecksList');
            
            const allDecks = [];
            Object.keys(savedDecks).forEach(game => {
                savedDecks[game].forEach(deck => {
                    allDecks.push({ ...deck, game });
                });
            });
            
            if (allDecks.length === 0) {
                listDiv.innerHTML = '<p class="text-xs text-center opacity-40">No decks saved yet</p>';
                return;
            }
            
            listDiv.innerHTML = allDecks.map(deck => {
                const totalCards = 
                    (deck.pokemon?.reduce((sum, c) => sum + c.quantity, 0) || 0) +
                    (deck.trainers?.reduce((sum, c) => sum + c.quantity, 0) || 0) +
                    (deck.energy?.reduce((sum, c) => sum + c.quantity, 0) || 0);
                
                return `
                    <div class="bg-base-300 p-2 rounded-lg">
                        <div class="flex justify-between items-start">
                            <div class="min-w-0 flex-1">
                                <p class="font-semibold text-sm truncate">${deck.name}</p>
                                <p class="text-xs opacity-60">${deck.game} • ${totalCards} cards</p>
                            </div>
                            <div class="flex gap-1 ml-2">
                                <button class="btn btn-xs btn-ghost" onclick="loadDeck('${deck.game}', '${escape(deck.name)}')">View</button>
                                <button class="btn btn-xs btn-error btn-ghost" onclick="deleteDeck('${deck.game}', '${escape(deck.name)}')">×</button>
                            </div>
                        </div>
                    </div>
                `;
            }).join('');
        }
        
        // Helper function to escape quotes in deck names
        window.escape = function(str) {
            return str.replace(/'/g, "\\'").replace(/"/g, '\\"');
        }
        
        // Load a saved deck
        window.loadDeck = function(game, deckName) {
            // Unescape the deck name
            deckName = deckName.replace(/\\'/g, "'").replace(/\\"/g, '"');
            
            const deck = savedDecks[game]?.find(d => d.name === deckName);
            if (!deck) return;
            
            currentImportedDeck = deck;
            
            // Switch to the deck's game if not already
            if (currentGame !== game) {
                selectGame(game, true);
            }
            
            // Display the deck view
            displayDeckView(deck, game);
        }
        
        // Delete a saved deck
        window.deleteDeck = function(game, deckName) {
            // Unescape the deck name
            deckName = deckName.replace(/\\'/g, "'").replace(/\\"/g, '"');
            
            if (!confirm(`Delete deck "${deckName}"?`)) return;
            
            savedDecks[game] = savedDecks[game].filter(d => d.name !== deckName);
            if (savedDecks[game].length === 0) {
                delete savedDecks[game];
            }
            
            localStorage.setItem('savedDecks', JSON.stringify(savedDecks));
            updateSavedDecksList();
        }
        
        // Export all decks
        window.exportAllDecks = function() {
            const dataStr = JSON.stringify(savedDecks, null, 2);
            const dataUri = 'data:application/json;charset=utf-8,'+ encodeURIComponent(dataStr);
            
            const exportLink = document.createElement('a');
            exportLink.setAttribute('href', dataUri);
            exportLink.setAttribute('download', `cardcast-decks-${new Date().toISOString().split('T')[0]}.json`);
            document.body.appendChild(exportLink);
            exportLink.click();
            document.body.removeChild(exportLink);
        }
        
        // Filter search to deck only
        window.updateSearchToDeckOnly = function() {
            if (!currentImportedDeck) return;
            
            // Get all card names from the deck
            const deckCardNames = new Set();
            ['pokemon', 'trainers', 'energy'].forEach(category => {
                if (currentImportedDeck[category]) {
                    currentImportedDeck[category].forEach(card => {
                        deckCardNames.add(card.name.toLowerCase());
                    });
                }
            });
            
            // Re-run search with deck filter
            const searchInput = document.getElementById('searchInput');
            if (searchInput.value) {
                handleSearch({ target: searchInput });
            }
        }
        
        // Override search to support deck filtering
        const originalHandleSearch = window.handleSearch;
        window.handleSearch = async function(event) {
            // Don't search if in deck view mode
            if (isDeckViewMode) return;
            
            const query = event.target.value.trim();
            
            if (!currentGame || query.length < 2) {
                clearSearchResults();
                return;
            }
            
            try {
                const response = await fetch(`/api/search/${currentGame}?q=${encodeURIComponent(query)}`);
                let results = await response.json();
                
                // Filter by deck if enabled
                if (document.getElementById('searchDeckOnly').checked && currentImportedDeck) {
                    const deckCardNames = new Set();
                    ['pokemon', 'trainers', 'energy'].forEach(category => {
                        if (currentImportedDeck[category]) {
                            currentImportedDeck[category].forEach(card => {
                                deckCardNames.add(card.name.toLowerCase());
                            });
                        }
                    });
                    
                    results = results.filter(card => 
                        deckCardNames.has(card.name.toLowerCase())
                    );
                }
                
                searchResults = results;
                displaySearchResults(results);
            } catch (error) {
                console.error('Search error:', error);
            }
        }
        
        // Initialize on load
        document.addEventListener('DOMContentLoaded', () => {
            updateSavedDecksList();
        });
        
        // All the other original functions remain the same...
        // (Include all the other functions from the original file here)
        
        // Display search results with DaisyUI cards
        window.displaySearchResults = function(results) {
            const resultsDiv = document.getElementById('searchResults');
            
            if (results.length === 0) {
                resultsDiv.innerHTML = `
                    <div class="flex flex-col items-center justify-center py-20">
                        <div class="text-6xl mb-4">🔍</div>
                        <h3 class="text-lg font-medium mb-1">No cards found</h3>
                        <p class="text-sm opacity-60">Try a different search term</p>
                    </div>
                `;
                return;
            }
            
            resultsDiv.innerHTML = `
                <div class="grid grid-cols-3 sm:grid-cols-4 lg:grid-cols-5 xl:grid-cols-6 gap-3">
                    ${results.map(card => `
                        <div class="cursor-pointer group card-result" onclick="selectCard('${card.id}')">
                            <div class="card-thumbnail">
                                <img 
                                    src="${card.display_image || card.local_image || card.image_url || '/images/card-back.png'}" 
                                    alt="${card.name}"
                                    class="w-full h-full object-cover rounded-lg group-hover:scale-105 transition-transform"
                                    loading="lazy"
                                />
                            </div>
                            <div class="mt-1">
                                <p class="text-sm font-medium truncate">${card.name}</p>
                                <p class="text-xs opacity-60">${card.set_name || ''} ${card.card_number ? '#' + card.card_number : ''}</p>
                            </div>
                        </div>
                    `).join('')}
                </div>
            `;
        }
        
        // Clear search results
        window.clearSearchResults = function() {
            document.getElementById('searchResults').innerHTML = `
                <div class="flex flex-col items-center justify-center py-20">
                    <div class="text-6xl mb-4">📦</div>
                    <p class="text-base-content/60">Select a game and download card data to begin</p>
                </div>
            `;
            searchResults = [];
        }
        
        // Create game element with DaisyUI styling
        window.createGameElement = function(game) {
            const gameItem = document.createElement('div');
            gameItem.className = 'game-item';
            gameItem.dataset.game = game.id;
            
            const hasData = game.hasData && game.cardCount > 0;
            const cardCountFormatted = game.cardCount >= 1000 
                ? `${(game.cardCount / 1000).toFixed(1)}k` 
                : `${game.cardCount}`;
            
            const gameColors = {
                pokemon: 'from-red-500 to-red-600',
                magic: 'from-orange-500 to-amber-600',
                yugioh: 'from-yellow-500 to-yellow-600',
                lorcana: 'from-purple-500 to-pink-600',
                onepiece: 'from-red-600 to-orange-600',
                digimon: 'from-blue-500 to-cyan-600',
                fab: 'from-rose-500 to-red-600',
                starwars: 'from-gray-500 to-slate-600'
            };
            
            gameItem.innerHTML = `
                <div class="flex items-center gap-3 flex-1">
                    <div class="avatar">
                        <div class="w-10 rounded-lg bg-gradient-to-br ${gameColors[game.id] || 'from-gray-500 to-gray-600'}">
                            <span class="text-white text-lg flex items-center justify-center h-full font-bold">
                                ${game.name[0]}
                            </span>
                        </div>
                    </div>
                    <div class="flex-1">
                        <div class="font-semibold">${game.name}</div>
                        <div class="text-xs opacity-60">
                            ${hasData ? `${cardCountFormatted} cards` : 'No data'}
                        </div>
                    </div>
                </div>
                <div class="flex gap-1">
                    ${hasData ? `
                        <button class="btn btn-xs btn-primary" onclick="event.stopPropagation(); updateGameData('${game.id}')">Update</button>
                        <button class="btn btn-xs btn-error btn-ghost" onclick="event.stopPropagation(); deleteGameData('${game.id}')">×</button>
                    ` : `
                        <button class="btn btn-xs btn-secondary" onclick="event.stopPropagation(); downloadGameData('${game.id}')">Download</button>
                    `}
                </div>
            `;
            
            gameItem.onclick = () => selectGame(game.id, hasData);
            
            return gameItem;
        }
        
        // Update card preview with DaisyUI styling
        window.updateCardPreview = function(card) {
            const previewDiv = document.getElementById('cardPreview');
            
            if (!card) {
                previewDiv.innerHTML = `
                    <div class="aspect-[63/88] bg-base-300 rounded-lg flex items-center justify-center">
                        <div class="text-center">
                            <div class="text-4xl mb-2">🎴</div>
                            <span class="text-base-content/40">No card selected</span>
                        </div>
                    </div>
                `;
                return;
            }
            
            previewDiv.innerHTML = `
                <div class="space-y-3">
                    <div class="aspect-[63/88] rounded-lg overflow-hidden bg-base-300">
                        <img 
                            src="${card.display_image || card.local_image || card.image_url || '/images/card-back.png'}" 
                            alt="${card.name}"
                            class="w-full h-full object-cover"
                        />
                    </div>
                    <div class="text-center">
                        <h3 class="font-semibold">${card.name}</h3>
                        <p class="text-sm opacity-60">${card.set_name || ''} ${card.card_number ? '#' + card.card_number : ''}</p>
                        ${card.hp ? `<p class="text-sm mt-1"><span class="opacity-60">HP:</span> <span class="font-semibold">${card.hp}</span></p>` : ''}
                    </div>
                </div>
            `;
        }
        
        // Update recent cards display
        window.updateRecentCardsDisplay = function() {
            const recentDiv = document.getElementById('recentCards');
            
            if (recentCards.length === 0) {
                recentDiv.innerHTML = '<p class="text-xs opacity-40">No recent cards</p>';
                return;
            }
            
            recentDiv.innerHTML = recentCards.map((card, index) => `
                <div class="cursor-pointer" onclick="selectCard('${card.id}')" title="${card.name}">
                    <div class="w-12 h-16 rounded overflow-hidden border border-base-300 hover:border-primary transition-colors">
                        <img 
                            src="${card.display_image || card.local_image || card.image_url || '/images/card-back.png'}" 
                            alt="${card.name}"
                            class="w-full h-full object-cover"
                        />
                    </div>
                </div>
            `).join('');
        }
        
        // Show/hide download progress
        window.showDownloadProgress = function(show) {
            const progress = document.getElementById('downloadProgress');
            if (show) {
                progress.classList.remove('hidden');
            } else {
                progress.classList.add('hidden');
            }
        }
        
        // Clear deck import
        window.clearDeckImport = function() {
            document.getElementById('deckNameInput').value = '';
            document.getElementById('deckImportText').value = '';
        }
    </script>
</body>
</html>